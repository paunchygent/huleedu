---
description: Docker development patterns - multi-stage builds, layer optimization, workflow commands
globs: ["Dockerfile*", "docker-compose*.yml", "scripts/dev.sh", "scripts/prod.sh"]
alwaysApply: true
---

# 087: Docker Development Patterns

## Multi-Stage Build Structure

### Required Stages
```dockerfile
FROM python:3.11-slim AS base
# Base: environment variables, system dependencies

FROM base AS development
# Development: volume mounts for hot-reload

FROM base AS production  
# Production: optimized for deployment
```

### Base Stage Pattern
```dockerfile
FROM python:3.11-slim AS base

ENV PYTHONUNBUFFERED=1 \
    PYTHONDONTWRITEBYTECODE=1 \
    PDM_USE_VENV=false \
    ENV_TYPE=docker \
    PYTHONPATH=/app

# Service-specific environment variables
ENV SERVICE_LOG_LEVEL=INFO \
    SERVICE_HTTP_PORT=7005 \
    SERVICE_PROMETHEUS_PORT=9097 \
    SERVICE_HOST=0.0.0.0

# Install system dependencies (rarely change - good cache layer)
RUN apt-get update && apt-get install -y --no-install-recommends curl build-essential python3-dev \
    && rm -rf /var/lib/apt/lists/* \
    && pip install --no-cache-dir pdm

WORKDIR /app

# Copy only dependency files first (better caching)
COPY libs/common_core/pyproject.toml /app/libs/common_core/pyproject.toml
COPY libs/huleedu_service_libs/pyproject.toml /app/libs/huleedu_service_libs/pyproject.toml
COPY services/SERVICE_NAME/pyproject.toml /app/services/SERVICE_NAME/pyproject.toml

# Generate lockfile and install dependencies
WORKDIR /app/services/SERVICE_NAME
RUN pdm lock --lockfile pdm.lock.docker || echo "Lock generation failed, will install without lock"

# Copy shared library source (changes less frequently than service code)
COPY libs/common_core/src/ /app/libs/common_core/src/
COPY libs/huleedu_service_libs/src/ /app/libs/huleedu_service_libs/src/

# Install dependencies (caches well if pyproject.toml doesn't change)
RUN if [ -f "pdm.lock.docker" ]; then pdm install --prod --lockfile pdm.lock.docker; else pdm install --prod; fi
```

### Development Stage Pattern
```dockerfile
FROM base AS development

# Create user and copy service code
RUN groupadd -r appuser && useradd --no-log-init -r -g appuser appuser
COPY services/SERVICE_NAME/ /app/services/SERVICE_NAME/
RUN chown -R appuser:appuser /app

USER appuser
WORKDIR /app/services/SERVICE_NAME

EXPOSE ${SERVICE_HTTP_PORT} ${SERVICE_PROMETHEUS_PORT}
CMD ["pdm", "run", "start"]
```

### Production Stage Pattern
```dockerfile
FROM base AS production

COPY services/SERVICE_NAME/ /app/services/SERVICE_NAME/
RUN groupadd -r appuser && useradd --no-log-init -r -g appuser appuser \
    && chown -R appuser:appuser /app

USER appuser
WORKDIR /app/services/SERVICE_NAME

EXPOSE ${SERVICE_HTTP_PORT} ${SERVICE_PROMETHEUS_PORT}
CMD ["pdm", "run", "start"]
```

## Development Workflow Commands

### Development Commands
```bash
pdm run dev-start [service]          # Start with hot-reload
pdm run dev-logs [service]           # View logs
pdm run dev-build-clean [service]    # Clean build
pdm run dev-check                    # Check what needs rebuilding
```

### Monitoring Commands
```bash
# View development logs
docker-compose -f docker-compose.yml -f docker-compose.dev.yml logs -f <service_name>

# Check container status
docker ps | grep huleedu

# Access container shell for debugging
docker exec -it huleedu_<service_name> /bin/bash
```

## Layer Caching Strategy

### Optimization Order
1. **System dependencies**: Rarely change, cached longest
2. **PDM installation**: Cached per Python version
3. **Dependency files**: Change only when dependencies update
4. **Shared library source**: Change more frequently than dependencies
5. **Service code**: Changes most frequently, shortest cache

### Performance Targets
- **Development builds**: < 10 seconds (first time may be longer)
- **Incremental builds**: 4-6 seconds
- **Cache hit rate**: > 95% for dependency layers
- **Code change to reflection**: < 3 seconds

## Development Compose Configuration

### docker-compose.dev.yml Structure
```yaml
services:
  service_name:
    build:
      context: .
      dockerfile: services/<service_name>/Dockerfile.dev
      target: development
    volumes:
      # Mount source code for hot-reload
      - ./services/<service_name>:/app/services/<service_name>:cached
      - ./libs/common_core/src:/app/libs/common_core/src:cached
      - ./libs/huleedu_service_libs/src:/app/libs/huleedu_service_libs/src:cached
      # Exclude build artifacts
      - /app/services/<service_name>/__pycache__
      - /app/services/<service_name>/__pypackages__
    environment:
      - ENV_TYPE=development
      - LOG_LEVEL=DEBUG
```

## Environment Variable Standards

### Framework-Specific Variables
```dockerfile
# Quart services
ENV QUART_APP=app:app \
    QUART_ENV=production

# FastAPI services  
ENV UVICORN_HOST=0.0.0.0 \
    UVICORN_PORT=${SERVICE_HTTP_PORT}
```

## Port Management

| Service Type | HTTP Port Range | Prometheus Port | Database Port Range |
|-------------|----------------|-----------------|-------------------|
| HTTP Services | 7001-7020 | HTTP + 2092 | 5441-5460 |
| Worker Services | N/A | 9000+ | 5441-5460 |

### Port Exposure Pattern
```dockerfile
# Use environment variables for flexible port configuration
EXPOSE ${SERVICE_HTTP_PORT} ${SERVICE_PROMETHEUS_PORT}
```

## Security Requirements

### Non-Root User Pattern
```dockerfile
# MUST create and use non-root user
RUN groupadd -r appuser && useradd --no-log-init -r -g appuser appuser \
    && chown -R appuser:appuser /app
USER appuser
```

### Minimal System Dependencies
```dockerfile
# Install only required system packages
RUN apt-get update && apt-get install -y --no-install-recommends \
    curl build-essential python3-dev \
    && rm -rf /var/lib/apt/lists/*
```

## Build Optimization Rules

### MUST Requirements
- **Dependencies before code**: Always copy pyproject.toml before source code
- **Multi-stage builds**: Use base → development → production stages
- **Dynamic lockfiles**: Generate lockfiles in container for flexibility
- **Layer separation**: Separate frequently changing from stable layers

### MUST NOT Requirements
- **NEVER use --no-cache** for development builds
- **NEVER copy source code before dependencies**
- **NEVER install dependencies in final stage only**
- **NEVER skip volume mounts for development services**

## Service-Specific Patterns

### HTTP Services (Quart/FastAPI)
- Expose service ports for external access
- Include health check endpoints
- Support both API and worker modes where applicable

### Worker Services (Kafka consumers)
- No port exposure required
- Focus on logging and monitoring
- Support graceful shutdown signals

### Health Check Integration
```dockerfile
# Optional: Add health check
HEALTHCHECK --interval=30s --timeout=10s --start-period=40s --retries=3 \
    CMD curl -f http://localhost:${SERVICE_HTTP_PORT}/health || exit 1
```

## Build Commands Reference

### Development Builds
```bash
# Development build with cache
docker build --target development -t SERVICE_NAME:dev .

# Production build
docker build --target production -t SERVICE_NAME:latest .

# Clean build (no cache)
docker build --no-cache --target development -t SERVICE_NAME:dev .
```

### Debug Commands
```bash
# Check build context and cache usage
docker build --progress=plain -f services/<service>/Dockerfile.dev .

# Inspect image layers
docker history <image_name>

# Check volume mounts
docker inspect huleedu_<service_name> | grep -A 10 "Mounts"
```

## Implementation Status

### Optimized Services
✅ nlp_service, batch_orchestrator_service, essay_lifecycle_service, spellchecker_service, file_service, content_service

### Template for Remaining Services
1. Create `Dockerfile.dev` with multi-stage pattern
2. Add service to `docker-compose.dev.yml`
3. Test development build: `pdm run dev-start <service>`
4. Verify hot-reload: Make code change and check logs
5. Validate performance: Measure build times

## Troubleshooting

### Common Issues
| Issue | Cause | Solution |
|-------|-------|----------|
| Build failures | PDM lockfile generation | Check dependency compatibility |
| Mount issues | Volume paths/permissions | Verify paths and user/group setup |
| Cache misses | Wrong copy order | Dependencies before source code |
| Permission errors | User/group setup | Check Dockerfile user creation |