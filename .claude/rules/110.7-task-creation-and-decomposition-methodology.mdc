---
description: Task Creation and Decomposition Methodology for Complex Implementation Projects
globs: 
alwaysApply: true
---
===
# 110.7: Task Creation and Decomposition Methodology

## 1. Overview

This rule defines a systematic methodology for creating complex implementation tasks that enable parallel development, reduce cognitive load, and ensure deep thinking through structured decomposition. Based on proven patterns from successful task implementations.

## 2. Main Task Structure Template

### 2.1 Required Sections

#### Executive Summary
- **Purpose**: Single sentence describing the core objective
- **Scope**: High-level boundaries and what's included/excluded
- **Integration Context**: How this fits into the larger system

#### Linked Subtasks
- **Format**: `Subtask {LETTER} â€” {Title}: TASKS/TASK-{ID}{LETTER}-{kebab-case-name}.md`
- **Self-Contained**: Each subtask must be implementable independently
- **Parallel-Ready**: Minimize blocking dependencies between subtasks

#### Architectural Alignment
- **Rule Citations**: Explicit references to relevant architectural rules
- **Pattern Templates**: References to existing implementations to follow
- **Standards Compliance**: Specific standards and blueprints to adhere to

#### System Integration
- **Data Flow**: High-level system interactions and data movement
- **Service Boundaries**: Clear interface definitions
- **Integration Points**: Where this component connects to existing systems

#### Contracts & Boundary Objects
- **Events**: Domain events and their schemas
- **APIs**: HTTP endpoints, request/response models
- **Protocols**: Interface definitions and contracts
- **Data Models**: Key domain objects and their relationships

#### Critical Constraints
- **Non-Negotiable Requirements**: Hard constraints that cannot be compromised
- **Performance Requirements**: Latency, throughput, resource limits
- **Compatibility Requirements**: Backward compatibility, integration constraints

#### Implementation Phases
- **Phase 0**: Architecture Study (read-only analysis)
- **Phase N**: Map each phase to specific subtasks
- **Dependencies**: Clear ordering and dependency relationships

#### Design Decisions
- **Key Architectural Choices**: Major design decisions and rationale
- **Trade-offs**: Decisions made and alternatives considered
- **Future Considerations**: Extensibility and evolution plans

#### Success Criteria
- **Functional**: Feature completeness and behavior validation
- **Architectural**: Pattern compliance and integration success
- **Operational**: Performance, reliability, and maintainability metrics

#### Risk Assessment
- **Technical Risks**: Implementation challenges and mitigation strategies
- **Integration Risks**: System interaction risks and solutions
- **Operational Risks**: Deployment and runtime considerations

#### Reference Materials
- **Rules**: Specific rule numbers and sections
- **Templates**: Existing services or components to use as patterns
- **Integration Points**: Specific files, classes, or endpoints to integrate with

### 2.2 Quality Gates

- [ ] All subtasks are self-contained and can be implemented independently
- [ ] Dependencies between subtasks are minimal and explicit
- [ ] Each subtask has clear boundary objects and contracts
- [ ] Architectural alignment is documented with specific rule citations
- [ ] Success criteria are measurable and specific
- [ ] Risk mitigation strategies are concrete and actionable

## 3. Subtask Structure Template

### 3.1 Required Sections

#### Objective
- **Single Goal**: One clear, specific objective per subtask
- **Measurable Outcome**: Concrete deliverable or behavior
- **Scope Boundaries**: What is and isn't included

#### Boundary Objects & Contracts
- **Protocols**: Interface definitions this subtask implements
- **Data Models**: Specific models created or modified
- **API Contracts**: HTTP endpoints, request/response schemas
- **Event Contracts**: Domain events published or consumed

#### Dependencies & Libraries
- **Shared Libraries**: Required frameworks and utilities
- **External Dependencies**: Third-party libraries or services
- **Internal Dependencies**: Other services or components required

#### Implementation Steps
- **Actionable Items**: Specific, concrete steps to complete
- **Ordered Sequence**: Steps in logical implementation order
- **Validation Points**: How to verify each step is complete

#### Acceptance Tests
- **Happy Path**: Primary success scenarios
- **Error Cases**: Failure modes and error handling
- **Integration Points**: Interaction with other components
- **Performance Criteria**: Specific performance requirements

#### Risk Mitigation
- **Subtask-Specific Risks**: Risks unique to this subtask
- **Mitigation Strategies**: Concrete approaches to address risks
- **Fallback Plans**: Alternative approaches if primary fails

#### Deliverables
- **Code Artifacts**: Specific files, classes, or modules
- **Documentation**: Required documentation updates
- **Tests**: Test files and coverage requirements
- **Configuration**: Environment or deployment configuration

### 3.2 Self-Containment Criteria

- [ ] Can be implemented without waiting for other subtasks (except explicit dependencies)
- [ ] Has all information needed for implementation
- [ ] Defines clear success criteria and validation methods
- [ ] Specifies all required dependencies and libraries
- [ ] Includes comprehensive acceptance tests

## 4. Decomposition Strategies

### 4.1 Layer-Based Decomposition

Organize subtasks by architectural layers:
- **Contracts/Models**: Foundation data structures and interfaces
- **Service Infrastructure**: Application framework and configuration
- **Core Logic**: Business logic and domain implementation
- **API Interface**: External interface and presentation layer
- **Integration**: External system connections and adapters
- **Deployment**: Containerization and infrastructure
- **Observability**: Monitoring, logging, and health checks

### 4.2 Dependency Ordering

Structure subtasks to minimize blocking:
- **Foundation First**: Contracts and models that others depend on
- **Parallel Middle**: Core implementation that can work simultaneously
- **Integration Last**: Components that depend on core implementation
- **Cross-Cutting**: Observability and deployment can often work independently

### 4.3 Bounded Context

Ensure clear ownership boundaries:
- **No Overlapping Implementation**: Each subtask owns distinct code areas
- **Explicit Integration Points**: Clear interfaces between subtasks
- **Independent Testing**: Each subtask can be tested in isolation
- **Separate Deliverables**: Distinct, non-overlapping outputs

## 5. Parallel Development Enablers

### 5.1 Clear Contracts
- Define interfaces before implementation
- Use protocols and abstract base classes
- Specify data models and event schemas
- Document API contracts with examples

### 5.2 Minimal Dependencies
- Identify true dependencies vs. nice-to-have integrations
- Use dependency inversion to reduce coupling
- Create mock implementations for testing
- Design for independent deployment

### 5.3 Explicit Integration
- Document all integration points
- Provide integration test scenarios
- Specify error handling between components
- Define monitoring and observability requirements

## 6. Cognitive Load Reduction

### 6.1 Single Responsibility
- Each subtask focuses on one architectural concern
- Avoid mixing infrastructure and business logic
- Separate read and write operations where appropriate
- Keep subtasks under reasonable complexity

### 6.2 Bounded Scope
- Clear start and end conditions
- Explicit inclusion/exclusion criteria
- Prevent feature creep through clear boundaries
- Focus on core requirements first

### 6.3 Reference Materials
- Provide specific examples and templates
- Reference existing implementations
- Include architectural rule citations
- Offer concrete patterns to follow

## 7. Deep Thinking Facilitation

### 7.1 Architecture Study Phase
- Dedicated read-only analysis phase
- Study existing patterns and implementations
- Understand architectural constraints and requirements
- Align with established standards and practices

### 7.2 Rule Integration
- Explicit citations to relevant architectural rules
- Reference established patterns and blueprints
- Ensure compliance with coding standards
- Align with testing and quality methodologies

### 7.3 Pattern Recognition
- Reference similar existing implementations
- Identify reusable patterns and components
- Leverage established libraries and frameworks
- Build on proven architectural decisions

## 8. Task Creation Process

### 8.1 Analysis Phase
1. **Understand Requirements**: Analyze the high-level need and context
2. **Study Architecture**: Review relevant rules, patterns, and existing implementations
3. **Identify Boundaries**: Determine system boundaries and integration points
4. **Define Contracts**: Specify key interfaces and data models

### 8.2 Decomposition Phase
1. **Identify Layers**: Determine architectural layers involved
2. **Map Dependencies**: Understand true dependencies vs. preferences
3. **Create Subtasks**: Break down into self-contained units
4. **Validate Independence**: Ensure subtasks can be implemented in parallel

### 8.3 Documentation Phase
1. **Create Main Task**: Use template to document overall objective
2. **Create Subtasks**: Use template for each decomposed unit
3. **Validate Completeness**: Ensure all aspects are covered
4. **Review Quality Gates**: Verify all criteria are met

## 9. Quality Assurance

### 9.1 Main Task Validation
- All sections are complete and specific
- Subtasks cover the entire scope
- Dependencies are minimal and explicit
- Success criteria are measurable

### 9.2 Subtask Validation
- Each subtask is self-contained
- Implementation steps are actionable
- Acceptance tests are comprehensive
- Deliverables are concrete and specific

### 9.3 Integration Validation
- All integration points are documented
- Contract compatibility is verified
- Error handling is specified
- Monitoring requirements are defined

## 10. Benefits

This methodology provides:
- **Parallel Development**: Teams can work independently on different subtasks
- **Reduced Complexity**: Each subtask has manageable scope and clear boundaries
- **Deep Thinking**: Architecture study and pattern references encourage thorough analysis
- **Quality Assurance**: Comprehensive acceptance tests and validation criteria
- **Risk Mitigation**: Explicit risk identification and mitigation strategies
- **Maintainability**: Clear documentation and reference materials for future work

===
