---
description: Defines the API Gateway Service. The primary client entry point. Handles JWT auth, proxies requests to downstream services, and provides secure API access.
globs: 
alwaysApply: false
---
# 020.10: API Gateway Service Architecture

## 1. Service Identity
- **Package**: `huleedu-api-gateway-service`
- **Folders**: `services/api_gateway_service/`
- **Port**: 4001 (client-facing), 8080 (internal Docker)
- **Stack**: FastAPI, Uvicorn, Dishka, `python-jose` & `PyJWT` (for JWT), `slowapi` (for rate limiting)
- **Purpose**: Secure, client-facing entry point for the HuleEdu platform. Handles API requests, authentication, and routing to internal services.

## 2. Core Architectural Patterns

The gateway acts as a mediator and Anti-Corruption Layer, implementing three distinct patterns for backend interaction.

### 2.1. Command Publishing
For asynchronous operations, the gateway publishes commands to Kafka and returns `202 Accepted`.
- **File**: `routers/batch_routes.py`
- **Endpoint**: `POST /v1/batches/{batch_id}/pipelines`
- **Logic**:
    1. Validates `batch_id` consistency between URL path and request body.
    2. Constructs a formal `ClientBatchPipelineRequestV1` event from `common_core`.
    3. Wraps the event in a standard `EventEnvelope`.
    4. Publishes to the `huleedu.commands.batch.pipeline.v1` Kafka topic via the injected `KafkaBus`.

### 2.2. Request Proxying
For synchronous CRUD operations, the gateway proxies requests to the appropriate internal service.
- **File Proxy (`routers/file_routes.py`)**:
    - **Endpoint**: `POST /v1/files/batch`
    - **Logic**: Handles `multipart/form-data`. Injects the authenticated `X-User-ID` header and forwards the request to the `file_service`.
- **Class Management Proxy (`routers/class_routes.py`)**:
    - **Endpoint**: `ANY /v1/classes/{path:path}`
    - **Logic**: A generic, streaming proxy. Captures all methods and paths under `/v1/classes/` and streams the request and response to/from the `class_management_service`.

### 2.3. Query with Status Mapping
For data retrieval, the gateway queries internal services and maps internal status representations to client-facing statuses.
- **File**: `routers/status_routes.py`
- **Endpoint**: `GET /v1/batches/{batch_id}/status`
- **Logic**:
    1.  Queries the `result_aggregator_service` for batch status.
    2.  **Status Mapping**: Maps internal `BatchStatus` (12 values) to client `BatchClientStatus` (7 semantic values) via `map_to_client_status()` function.
    3.  **Status Values**: `pending_content`, `ready`, `processing`, `completed_successfully`, `completed_with_failures`, `failed`, `cancelled`
    4.  **Ownership Enforcement**: Validates that the `user_id` in the downstream service's response payload matches the JWT's `sub` claim.
    5.  **Consistency Guarantee**: REST API returns identical status values as WebSocket notifications.

## 3. Security Implementation

### 3.1. JWT Authentication
- **File**: `auth.py`
- **Mechanism**: The `get_current_user_id` dependency uses `OAuth2PasswordBearer` to extract the token.
- **Validation**:
    1.  Decodes the token using `settings.JWT_SECRET_KEY`.
    2.  Validates the signature and algorithm (`HS256`).
    3.  **Critically**, it validates the `exp` (expiration) claim against the current time.
    4.  Extracts the user ID from the `sub` claim.

### 3.2. Rate Limiting
- **File**: `app/rate_limiter.py`
- **Mechanism**: Uses `slowapi`. The key is dynamically set to the authenticated `user_id` (from request state) or falls back to the client's IP address.
- **Configuration**: Limits are applied directly to routes via the `@limiter.limit(...)` decorator (e.g., `10/minute`).