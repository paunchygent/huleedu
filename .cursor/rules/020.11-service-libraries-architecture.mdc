---
description: Defines the HuleEdu Service Libraries architecture. Shared components for cross-service functionality including Kafka, Redis, logging, and common utilities.
globs: 
alwaysApply: false
---

# 020.11: Service Libraries Architecture

## 1. Library Identity
- **Package**: `huleedu-service-libs`
- **Location**: `libs/huleedu_service_libs/`
- **Purpose**: Shared utilities and clients for HuleEdu microservices
- **Consumers**: All HuleEdu services

## 2. Architecture & Structure

```
libs/huleedu_service_libs/
├── README.md
├── pyproject.toml
├── src/
│   └── huleedu_service_libs/
│       ├── __init__.py              # Main exports
│       ├── kafka_client.py          # KafkaBus async wrapper for aiokafka
│       ├── redis_client.py          # RedisClient for key-value & atomic ops
│       ├── redis_pubsub.py          # RedisPubSub for pub/sub operations
│       ├── logging_utils.py         # Structured JSON logging with service context
│       ├── metrics_middleware.py    # HTTP metrics collection middleware
│       ├── event_utils.py           # Event processing utilities
│       ├── idempotency_v2.py        # Idempotent message processing decorator
│       ├── protocols.py             # Shared protocol definitions
│       ├── database/               # Database monitoring & health
│       │   ├── __init__.py
│       │   ├── health_checks.py    # DatabaseHealthChecker class
│       │   ├── metrics.py          # Database metrics collection
│       │   └── query_monitoring.py # Query performance tracking
│       ├── middleware/              # Framework-specific middleware
│       │   ├── __init__.py         # Framework-agnostic base
│       │   └── frameworks/         # Framework implementations
│       │       ├── quart_middleware.py    # Quart/async middleware
│       │       └── fastapi_middleware.py  # FastAPI/Starlette middleware
│       ├── observability/           # Distributed tracing utilities
│       │   ├── __init__.py
│       │   └── tracing.py          # OpenTelemetry integration
│       ├── resilience/             # Circuit breaker and resilience patterns
│       │   ├── __init__.py
│       │   ├── circuit_breaker.py  # Circuit breaker implementation
│       │   ├── registry.py         # Circuit breaker registry
│       │   └── resilient_client.py # Generic resilient wrapper
│       ├── error_handling/         # Enhanced error context
│       │   ├── __init__.py
│       │   └── factories.py        # Error context with tracing
│       └── py.typed                # Type stub marker
└── tests/                          # Test suite
    ├── test_idempotency.py
    └── test_redis_pubsub.py
```

## 3. Core Components

### 3.1. KafkaBus
- **Purpose**: Simplified async Kafka producer wrapper
- **Key Methods**: `start()`, `stop()`, `publish_event()`
- **Features**: Connection pooling, graceful shutdown, automatic serialization

### 3.2. RedisClient
- **Purpose**: Key-value operations and atomic transactions
- **Key Methods**: 
  - `set_if_not_exists()`: Atomic SET NX for idempotency
  - `watch()`, `multi()`, `exec()`: Transaction support
  - `scan_pattern()`: Key pattern scanning
- **Lifecycle**: Explicit `start()` and `stop()` methods
- **Delegation**: Pub/sub operations delegated to `RedisPubSub`

### 3.3. RedisPubSub
- **Purpose**: Redis pub/sub operations (extracted for SRP)
- **Key Methods**:
  - `publish()`: Publish messages to channels
  - `subscribe()`: Context manager for subscriptions
  - `get_user_channel()`: Standard channel naming (`ws:{user_id}`)
  - `publish_user_notification()`: Structured notification publishing
- **Critical**: Enables WebSocket backplane for real-time updates

### 3.4. Logging Utilities
- **Function**: `create_service_logger(name: str)`
- **Format**: Structured JSON with service context
- **Fields**: timestamp, level, service, module, message, extra context
- **Standard**: All services use this for consistent logging

### 3.5. Database Utilities
- **DatabaseHealthChecker**: Comprehensive PostgreSQL health monitoring
- **Key Methods**:
  - `check_basic_connectivity()`: Test database connection
  - `check_connection_pool_health()`: Monitor pool utilization
  - `check_query_performance()`: Benchmark query latency
  - `get_health_summary()`: Aggregated health status
- **Database Monitoring**: Prometheus metrics for database operations
  - Connection pool metrics (active, idle, total, overflow)
  - Query duration histograms by operation and table
  - Transaction duration and error tracking

### 3.6. HTTP Metrics Middleware
- **Function**: `setup_standard_service_metrics_middleware(app, service_name)`
- **Metrics Collected**:
  - Request count by method, endpoint, status
  - Request duration histogram
  - Active request gauge
- **Integration**: Applied during app initialization

### 3.7. Idempotency Decorator
- **Function**: `@idempotent_consumer(redis_client, ttl_seconds)`
- **Purpose**: Prevent duplicate Kafka message processing
- **Features**:
  - Deterministic event ID generation
  - Atomic Redis SET NX operations
  - Automatic lock release on failure
  - Fail-open on Redis errors

### 3.8. Event Utilities
- **Functions**:
  - `extract_user_id_from_event_data()`: Extract user for notifications
  - `generate_deterministic_event_id()`: Create idempotency keys
  - `extract_correlation_id_from_event()`: Trace context extraction
- **Usage**: Event processing and user notification routing

### 3.9. Protocols
- **`RedisClientProtocol`**: Basic Redis operations interface
- **`AtomicRedisClientProtocol`**: Extended with transactions
- **`KafkaPublisherProtocol`**: Event publishing interface
- **Benefits**: Protocol-based testing, clean dependency injection

## 4. Design Patterns

### 4.1. Lifecycle Management
- Services have explicit `start()` and `stop()` methods
- Managed by DI containers or startup hooks
- Ensures proper resource cleanup

### 4.2. Protocol-Based Design
- All major components expose protocols
- Enables clean mocking in tests
- Supports multiple implementations

### 4.3. Separation of Concerns
- Redis functionality split between key-value and pub/sub
- Each component under 400 LoC limit
- Single responsibility per module

## 5. Integration Patterns

### 5.1. Dependency Injection
```python
@provide(scope=Scope.APP)
async def provide_redis_client(settings: Settings) -> AtomicRedisClientProtocol:
    client = RedisClient(
        client_id=f"{settings.SERVICE_NAME}-redis",
        redis_url=settings.REDIS_URL,
    )
    await client.start()
    return cast(AtomicRedisClientProtocol, client)
```

### 5.2. Event Publishing
```python
async def publish_event(kafka_bus: KafkaBus, envelope: EventEnvelope):
    await kafka_bus.publish_event(
        topic=topic_name(envelope.event_type),
        event_envelope=envelope
    )
```

### 5.3. Redis Pub/Sub
```python
# Publishing
await redis_client.publish_user_notification(
    user_id="user123",
    event_type="batch_status_update",
    data={"batch_id": "...", "status": "..."}
)

# Subscribing
async with redis_client.subscribe("ws:user123") as pubsub:
    async for msg in pubsub.listen():
        # Process message
```

### 5.4. Circuit Breaker Metrics Integration
```python
# Service metrics setup
class ServiceMetrics:
    def __init__(self):
        self.circuit_breaker = StandardCircuitBreakerMetrics()

# During circuit breaker events
metrics.circuit_breaker.record_state_change(name="external_api", state="open")
metrics.circuit_breaker.record_call_result(name="external_api", success=False, duration=1.2)
```

## 6. Critical Requirements

### 6.1. Redis Client
- **MUST** call `start()` before use
- **MUST** handle connection failures gracefully
- **MUST** support atomic operations for idempotency

### 6.2. Kafka Client
- **MUST** serialize EventEnvelope to JSON
- **MUST** handle producer errors without crashing
- **MUST** support graceful shutdown

### 6.3. Logging
- **MUST** output structured JSON
- **MUST** include service name in all logs
- **MUST** support correlation IDs in extra context

### 6.4. Framework-Specific Middleware
**Pattern for avoiding framework coupling**:
```python
# Import only what you need
# Quart services
from huleedu_service_libs.middleware.frameworks.quart_middleware import setup_tracing_middleware

# FastAPI services  
from huleedu_service_libs.middleware.frameworks.fastapi_middleware import setup_tracing_middleware
```

### 6.5. Observability Utilities
- **init_tracing(service_name)**: Initialize OpenTelemetry tracer
- **trace_operation(tracer, name, attributes)**: Context manager for spans
- **inject_trace_context(carrier)**: Add trace to event metadata
- **extract_trace_context(carrier)**: Extract trace from events
- **get_current_trace_id()**: Get active trace ID for correlation

### 6.6. Resilience Patterns
- **CircuitBreaker**: Prevent cascading failures with configurable thresholds
- **CircuitBreakerRegistry**: Centralized management of circuit breakers
- **make_resilient(impl, breaker)**: Wrap any protocol with circuit breaker
- **ErrorContext**: Rich error context with trace information
- **StandardCircuitBreakerMetrics**: Prometheus metrics bridge for circuit breaker state
- **Pattern**: Use with DI to wrap HTTP clients, Kafka producers, external APIs

### 6.7. Database Monitoring Requirements
- **MUST** call `setup_database_monitoring()` for all PostgreSQL services
- **MUST** store DatabaseHealthChecker on app for health endpoints
- **MUST** use `@query_performance_tracker` for critical queries
- **Pattern**: Integrate in startup_setup.py during database initialization

### 6.8. Idempotency Requirements
- **MUST** wrap all Kafka consumers with `@idempotent_consumer`
- **MUST** use deterministic event IDs from message content
- **MUST** handle idempotency failures gracefully (log and continue)
- **Pattern**: Fail-open design - process if Redis unavailable

### 6.9. Metrics Collection
- **MUST** apply HTTP metrics middleware to all services
- **MUST** use consistent label naming (method, endpoint, status)
- **MUST** integrate with service registry for aggregation
- **Pattern**: Middleware applied in app factory function

## 7. Testing Considerations

### 7.1. Mock Implementations
- Use `AsyncMock(spec=Protocol)` for testing
- Mock at protocol level, not implementation
- Simulate realistic behavior (timeouts, failures)

### 7.2. Integration Testing
- Redis: Use testcontainers or real instance
- Kafka: Use testcontainers for full integration
- Verify lifecycle management works correctly
- Observability: Optional, mock tracer in unit tests