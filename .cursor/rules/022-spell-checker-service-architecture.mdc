---
description: defines the architecture and implementation details of the HuleEdu Spell Checker Service
globs: 
alwaysApply: false
---
# 022: Spell Checker Service Architecture

## 1. Service Identity
- **Package**: `huleedu-spell-checker-service`
- **Type**: Kafka Consumer Worker (no HTTP API)
- **Stack**: aiokafka, aiohttp, Python asyncio, Dishka (for DI - planned in Δ-2)
- **Purpose**: Event-driven spell checking service

## 2. Internal Structure (Refactored in Δ-3)
- **`worker_main.py`**: Handles service lifecycle (startup, shutdown), Kafka client management (consumer/producer via `kafka_clients` context manager), signal handling, and the primary message consumption loop. Initializes protocol implementations (manually for now, will use Dishka) and passes them to `process_single_message`.
- **`event_router.py`**: 
    - Contains `process_single_message()`: Handles incoming `ConsumerRecord`, deserializes the `EventEnvelope[SpellcheckRequestedDataV1]`, orchestrates the fetch-spellcheck-store-publish flow by calling appropriate protocol methods.
    - Implements `DefaultContentClient`, `DefaultResultStore`, `DefaultSpellLogic`, `DefaultSpellcheckEventPublisher` which adhere to the contracts in `protocols.py` and compose functions from `core_logic.py`.
- **`core_logic.py`**: Provides fundamental, reusable functions:
    - `default_fetch_content_impl()`: Fetches content via HTTP.
    - `default_store_content_impl()`: Stores content via HTTP.
    - `default_perform_spell_check_algorithm()`: The core (currently dummy) spell check logic.
- **`protocols.py`**: Defines `typing.Protocol` interfaces for internal dependencies:
    - `ContentClientProtocol`
    - `SpellLogicProtocol`
    - `ResultStoreProtocol`
    - `SpellcheckEventPublisherProtocol`

## 3. Event-Driven Architecture

**Consumes**: `essay.spellcheck.requested.v1` (`SpellcheckRequestedDataV1`)
**Publishes**: `essay.spellcheck.completed.v1` (via `DefaultSpellcheckEventPublisher` using `SpellcheckResultDataV1`)
**Consumer Group**: `spellchecker-service-group` (from settings)

**Flow**: `worker_main.py` consumes message ➜ `process_single_message` in `event_router.py` orchestrates: `ContentClientProtocol.fetch_content` ➜ `SpellLogicProtocol.perform_spell_check` (which uses `default_perform_spell_check_algorithm`) ➜ `ResultStoreProtocol.store_content` ➜ `SpellcheckEventPublisherProtocol.publish_spellcheck_result` ➜ `worker_main.py` commits offset.

## 4. Integration Points

- **Content Service**: HTTP REST API via aiohttp.ClientSession
- **Kafka**: AIOKafkaConsumer/Producer with manual offset management

## 5. Spell Checking Implementation

**Current**: Dummy implementation with simple replacements ("teh" → "the")
**Future**: pyspellchecker, symspellpy, or SparkNLP integration

## 6. Configuration

**Environment**: `KAFKA_BOOTSTRAP_SERVERS`, `CONTENT_SERVICE_URL`, `LOG_LEVEL`
**Dependencies**: aiokafka, aiohttp, huleedu-common-core, huleedu-service-libs

## 7. Error Handling

**Scenarios**: Content Service unavailable, invalid event format, spell check failure
**Pattern**: Log error, commit offset, skip/publish failure event
**Future**: Circuit breaker, dead letter queue, retry logic

## 8. Data Models

**Input**: `SpellcheckRequestedDataV1` with entity_ref, system_metadata, text_storage_id
**Output**: `SpellcheckResultDataV1` with entity_ref, system_metadata, storage_metadata, corrections_made

## 9. Deployment

**Docker**: `python:3.11-slim` base, PDM, `python -m services.spell_checker_service.worker_main` (updated entry point if module execution is preferred)
**Command**: `pdm run -p services/spell_checker_service start_worker` (assuming `start_worker` script in `pyproject.toml` points to `python -m services.spell_checker_service.worker_main` or similar)

## 10. Future Enhancements

**Security**: Service auth, message encryption, input sanitization
**Performance**: Parallel processing, content caching, batch spell checking
