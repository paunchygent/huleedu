---
description: Read before all work on web framework, I/O, API etc
globs: 
alwaysApply: false
---
# 040: Service Implementation Guidelines

## 1. Frameworks & Libraries

### 1.1. Quart for Service Implementation
- **Framework**: Quart **SHALL** be primary web framework for async microservices
- **MUST** use Quart's native async capabilities for all request handling and I/O

### 1.2. PDM for Dependency Management
- Manage Python dependencies exclusively with PDM (`pyproject.toml`, `pdm.lock`)
- Add/update dependencies using PDM commands, ensuring `pdm.lock` is current

## 2. Asynchronous Programming

### 2.1. Embrace `async/await`
- All I/O-bound operations (network, DB, file system) **MUST** use `async/await` and async-compatible libraries
- **MUST** avoid blocking calls in async code paths

### 2.2. Proper Async Context Management
- Use `async with` for async context managers
- Manage task lifecycles and cancellation correctly

### 2.3. Dependency Injection for Testability
```python
async def process_single_message(
    msg: ConsumerRecord,
    producer: AIOKafkaProducer,
    http_session: aiohttp.ClientSession,
    fetch_content_func: FetchContentFunc,
    store_content_func: StoreContentFunc,
    perform_processing_func: ProcessingFunc,
) -> bool:
```

### 2.4. Resource Lifecycle Management
```python
@asynccontextmanager
async def kafka_clients(
    input_topic: str,
    consumer_group_id: str,
    client_id_prefix: str,
    bootstrap_servers: str,
) -> Any:
    # Setup/teardown logic
```

## 3. State Management

### 3.1. Batch Orchestration Service State
- **Responsibility**: Exclusively manages `BatchUpload.status` and `BatchUpload.processing_metadata` (holding `ProcessingPipelineState`)
- Strictly follow state transition logic and `ProcessingPipelineState` updates from Architectural Design Blueprint

### 3.2. Essay Lifecycle Service State
- **Responsibility**: Exclusively manages `ProcessedEssay.status`
- Strictly follow `EssayStatus` enum and transition logic from Architectural Design Blueprint

### 3.3. Clear State Ownership & Eventing
- Each service owns its primary entities' state
- Significant state changes **MUST** be communicated via events published by owning service

## 4. Internal API Design (If Applicable)
If a service exposes synchronous APIs (use sparingly):
- **MUST** follow RESTful principles
- **MUST** use Pydantic models (from `common/` or service-specific) for request/response schemas
- **MUST** include API versioning (e.g., `/v1/...`)
- **MUST** use `ErrorInfoModel` (from `common/`) for standardized error responses

## 5. Configuration Management

### 5.1. Standardized Pydantic Settings Pattern
- **MUST** use `pydantic-settings` for all service configuration
- **MUST** create `config.py` at service root with this pattern:

```python
from __future__ import annotations
from pydantic_settings import BaseSettings, SettingsConfigDict

class Settings(BaseSettings):
    """Configuration settings for the [Service Name]."""
    LOG_LEVEL: str = "INFO"
    # Add typed fields with defaults
    
    model_config = SettingsConfigDict(
        env_file=".env",
        env_file_encoding="utf-8",
        extra="ignore",
        env_prefix="[SERVICE_NAME]_",
    )

settings = Settings()
```

### 5.2. Configuration Usage
- Import settings: `from .config import settings`
- Use `settings.FIELD_NAME` instead of `os.getenv()`
- Sensitive info **MUST NEVER** be hardcoded

## 6. Logging

### 6.1. Structured Logging (JSON)
- Use structured logging (e.g., `python-json-logger`) for machine-readable JSON logs

### 6.2. Mandatory Correlation IDs
- For any operation chain (request/event), a `correlation_id` **MUST** be established or propagated
- This `correlation_id` **MUST** be in all log messages across all involved services
- **MUST** ensure logging statements include the `correlation_id`

### 6.3. Consistent Log Levels & Clear Messages
- Use appropriate levels (`DEBUG`, `INFO`, `WARNING`, `ERROR`, `CRITICAL`)
- Log messages **MUST** be clear, concise, and contextual
