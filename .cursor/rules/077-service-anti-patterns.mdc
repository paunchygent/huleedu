# Rule 077: Service Anti-Patterns to Avoid

## Overview

This rule documents anti-patterns discovered across HuleEdu services and their corrections. These patterns violate architectural principles, create maintenance issues, or prevent proper production deployment.

## 1. Infrastructure Client Anti-Patterns

### ❌ Direct Infrastructure Imports

**Anti-pattern**:
```python
# WRONG - Direct import
from redis.asyncio import Redis
from aiokafka import AIOKafkaProducer
import aiohttp

redis = Redis(host="redis", port=6379)
producer = AIOKafkaProducer(bootstrap_servers="kafka:9092")
```

**✅ Correct Pattern**:
```python
# RIGHT - Use service libraries
from huleedu_service_libs import RedisClient, KafkaBus
from huleedu_service_libs.protocols import RedisClientProtocol, KafkaPublisherProtocol

# In DI provider
redis_client = RedisClient(client_id="service-redis")
kafka_bus = KafkaBus(client_id="service-producer")
```

### ❌ Missing Lifecycle Management

**Anti-pattern**:
```python
# WRONG - No lifecycle management
@provide(scope=Scope.APP)
async def provide_redis(settings: Settings) -> RedisClientProtocol:
    return RedisClient(client_id="service", redis_url=settings.REDIS_URL)
```

**✅ Correct Pattern**:
```python
# RIGHT - Proper lifecycle
@provide(scope=Scope.APP)
async def provide_redis(settings: Settings) -> RedisClientProtocol:
    client = RedisClient(client_id="service", redis_url=settings.REDIS_URL)
    await client.start()  # REQUIRED
    return client

# In teardown
await client.stop()  # REQUIRED
```

## 2. Logging Anti-Patterns

### ❌ Standard Library Logging

**Anti-pattern**:
```python
# WRONG - Standard library
import logging
logger = logging.getLogger(__name__)
logger.info(f"Processing {event_id}")
```

**✅ Correct Pattern**:
```python
# RIGHT - Service library structured logging
from huleedu_service_libs.logging_utils import create_service_logger
logger = create_service_logger("service.module")
logger.info("Processing event", event_id=event_id, user_id=user_id)
```

### ❌ Logger Import in Functions

**Anti-pattern** (found in CJ Assessment Service):
```python
async def health_check():
    try:
        # ...
    except Exception as e:
        from huleedu_service_libs.logging_utils import create_service_logger
        logger = create_service_logger("service")  # WRONG
```

**✅ Correct Pattern**:
```python
# Module level import
from huleedu_service_libs.logging_utils import create_service_logger
logger = create_service_logger("service.api.health")

async def health_check():
    try:
        # ...
    except Exception as e:
        logger.error(f"Health check failed: {e}")
```

## 3. Health Endpoint Anti-Patterns

### ❌ Inconsistent Health Endpoints

**Anti-pattern** (Class Management Service):
```python
# WRONG - PostgreSQL service without database health endpoints
@health_bp.route("/healthz")  # Only basic health
async def health_check():
    # Missing /healthz/database and /healthz/database/summary
```

**✅ Correct Pattern**:
```python
# RIGHT - Full three-tier for PostgreSQL services
@health_bp.route("/healthz")
@health_bp.route("/healthz/database")
@health_bp.route("/healthz/database/summary")
```

### ❌ Hardcoded Values

**Anti-pattern**:
```python
# WRONG - Hardcoded environment
health_response = {
    "service": "class_management",  # Hardcoded
    "environment": "development",    # Hardcoded
    "version": "1.0.0"              # Hardcoded
}
```

**✅ Correct Pattern**:
```python
# RIGHT - From settings
health_response = {
    "service": settings.SERVICE_NAME,
    "environment": settings.ENVIRONMENT,
    "version": settings.SERVICE_VERSION
}
```

### ❌ Missing Database Engine Storage

**Anti-pattern**:
```python
# WRONG - Engine not stored on app
engine = create_async_engine(settings.DATABASE_URL)
# Missing: app.database_engine = engine
```

**✅ Correct Pattern**:
```python
# RIGHT - Store for health checks
engine = create_async_engine(settings.DATABASE_URL)
app.database_engine = engine
app.health_checker = DatabaseHealthChecker(engine, settings.SERVICE_NAME)
```

## 4. Event Processing Anti-Patterns

### ❌ Missing Idempotency

**Anti-pattern**:
```python
# WRONG - No idempotency check
async def handle_message(msg: ConsumerRecord):
    envelope = EventEnvelope.model_validate_json(msg.value)
    await process_event(envelope)  # Might process duplicates
```

**✅ Correct Pattern**:
```python
# RIGHT - Idempotent consumer
from huleedu_service_libs.idempotency import idempotent_consumer

@idempotent_consumer(redis_client=redis_client, ttl_seconds=86400)
async def handle_message(msg: ConsumerRecord):
    envelope = EventEnvelope.model_validate_json(msg.value)
    await process_event(envelope)  # Automatically prevents duplicates
```

### ❌ Missing Trace Context

**Anti-pattern**:
```python
# WRONG - No trace propagation
envelope = EventEnvelope(
    event_type="ESSAY_SUBMITTED",
    source_service="essay_service",
    data=event_data
)
await kafka_bus.publish(topic, envelope)
```

**✅ Correct Pattern**:
```python
# RIGHT - Trace context propagation
from huleedu_service_libs.observability import inject_trace_context

envelope = EventEnvelope(
    event_type="ESSAY_SUBMITTED",
    source_service="essay_service",
    data=event_data,
    metadata={}
)
inject_trace_context(envelope.metadata)
await kafka_bus.publish(topic, envelope)
```

## 5. Database Anti-Patterns

### ❌ Using create_all() Instead of Migrations

**Anti-pattern**:
```python
# WRONG - Direct schema creation
async with engine.begin() as conn:
    await conn.run_sync(Base.metadata.create_all)
```

**✅ Correct Pattern**:
```python
# RIGHT - Use Alembic migrations
from alembic.config import Config
from alembic import command

alembic_cfg = Config("alembic.ini")
command.upgrade(alembic_cfg, "head")
```

### ❌ Missing Database Monitoring

**Anti-pattern**:
```python
# WRONG - No monitoring setup
engine = create_async_engine(settings.DATABASE_URL)
# Missing database metrics
```

**✅ Correct Pattern**:
```python
# RIGHT - Setup monitoring
from huleedu_service_libs.database import setup_database_monitoring

engine = create_async_engine(settings.DATABASE_URL)
db_metrics = setup_database_monitoring(engine, settings.SERVICE_NAME)
app.extensions["db_metrics"] = db_metrics
```

## 6. Dependency Injection Anti-Patterns

### ❌ Resource Leaks in Providers

**Anti-pattern**:
```python
# WRONG - No cleanup
@provide(scope=Scope.APP)
async def provide_http_client() -> aiohttp.ClientSession:
    return aiohttp.ClientSession()  # Who closes this?
```

**✅ Correct Pattern**:
```python
# RIGHT - Managed lifecycle
@provide(scope=Scope.APP)
async def provide_http_client() -> aiohttp.ClientSession:
    session = aiohttp.ClientSession(
        timeout=aiohttp.ClientTimeout(total=30)
    )
    yield session
    await session.close()  # Cleanup on shutdown
```

### ❌ Missing Circuit Breakers

**Anti-pattern**:
```python
# WRONG - Direct external service usage
@provide(scope=Scope.APP)
async def provide_llm_client(settings: Settings) -> LLMProtocol:
    return OpenAIClient(api_key=settings.OPENAI_API_KEY)
```

**✅ Correct Pattern**:
```python
# RIGHT - Wrapped with circuit breaker
from huleedu_service_libs.resilience import CircuitBreaker, make_resilient

@provide(scope=Scope.APP)
async def provide_llm_client(
    settings: Settings,
    metrics: ServiceMetrics
) -> LLMProtocol:
    client = OpenAIClient(api_key=settings.OPENAI_API_KEY)
    breaker = CircuitBreaker(
        name="openai",
        failure_threshold=3,
        recovery_timeout=timedelta(seconds=60),
        metrics=metrics.circuit_breaker
    )
    return make_resilient(client, breaker)
```

## 7. Metrics Anti-Patterns

### ❌ Multiple Registry Instances

**Anti-pattern**:
```python
# WRONG - Creates multiple registries
from prometheus_client import Counter, Histogram, REGISTRY

# In different modules
request_count = Counter(...)  # Uses default REGISTRY
request_duration = Histogram(...)  # Uses default REGISTRY
```

**✅ Correct Pattern**:
```python
# RIGHT - Single registry via DI
@provide(scope=Scope.APP)
def provide_registry() -> CollectorRegistry:
    return CollectorRegistry()

@provide(scope=Scope.APP)
def provide_metrics(registry: CollectorRegistry) -> ServiceMetrics:
    return ServiceMetrics(registry)
```

### ❌ Inconsistent Label Names

**Anti-pattern**:
```python
# WRONG - Different label names
# File Service
labels=["method", "endpoint", "status"]
# Other services
labels=["method", "endpoint", "status_code"]
```

**✅ Correct Pattern**:
```python
# RIGHT - Consistent labels
labels=["method", "endpoint", "status_code"]  # Always status_code
```

## 8. Configuration Anti-Patterns

### ❌ Direct Config Property Access

**Anti-pattern** (Spell Checker Service):
```python
# WRONG - Direct property
class Settings(BaseSettings):
    DATABASE_URL: str  # Used directly in alembic
```

**✅ Correct Pattern**:
```python
# RIGHT - Property method
class Settings(BaseSettings):
    DB_HOST: str
    DB_PORT: int
    DB_NAME: str
    DB_USER: str
    DB_PASSWORD: str
    
    @property
    def database_url(self) -> str:
        """Database URL for Alembic migration configuration."""
        return f"postgresql+asyncpg://{self.DB_USER}:{self.DB_PASSWORD}@{self.DB_HOST}:{self.DB_PORT}/{self.DB_NAME}"
```

## 9. Startup Anti-Patterns

### ❌ Silent Startup Failures

**Anti-pattern**:
```python
# WRONG - Swallows errors
try:
    await setup_database(app, settings)
except Exception as e:
    logger.error(f"Database setup failed: {e}")
    # Continues running with broken state
```

**✅ Correct Pattern**:
```python
# RIGHT - Fail fast
try:
    await setup_database(app, settings)
except Exception as e:
    logger.critical(f"Failed to initialize database: {e}")
    raise  # Stop startup
```

## 10. Testing Anti-Patterns

### ❌ Testing Concrete Implementations

**Anti-pattern**:
```python
# WRONG - Mocking concrete class
mock_redis = AsyncMock(spec=RedisClient)
```

**✅ Correct Pattern**:
```python
# RIGHT - Mock the protocol
mock_redis = AsyncMock(spec=RedisClientProtocol)
```

## Summary

These anti-patterns were discovered through analysis of actual service implementations. Key themes:

1. **Always use service libraries** - Never import infrastructure directly
2. **Lifecycle management is mandatory** - Always start() and stop()
3. **Consistency across services** - Same patterns everywhere
4. **Fail fast on errors** - Don't hide startup failures
5. **Monitor everything** - Database, HTTP, circuit breakers
6. **Test protocols, not implementations** - Better isolation

Following these patterns ensures production readiness and maintainability across all HuleEdu services.