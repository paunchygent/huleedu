---
description: Comprehensive Docker development workflow for optimized builds and hot-reload development
globs: ["Dockerfile*", "docker-compose*.yml", "scripts/dev-workflow.sh"]
alwaysApply: true
---
# 081: Docker Development Workflow

## 1. Overview

This rule defines the optimized Docker development workflow that eliminates the need for `--no-cache` builds and provides instant hot-reload capabilities for efficient development.

### 1.1. Performance Achievements
- **Incremental builds**: 4-6 seconds (99% improvement over --no-cache)
- **Hot-reload**: Instant code changes via volume mounts
- **Layer caching**: 99%+ cache hit rate for dependencies
- **Development velocity**: Eliminates 8+ minute rebuild delays

## 2. Development Workflow Commands

### 2.1. Primary Development Commands
```bash
# Start development environment with hot-reload
./scripts/dev-workflow.sh dev <service_name>

# Start multiple services in development mode
docker-compose -f docker-compose.yml -f docker-compose.dev.yml up <service1> <service2>

# Check what services need rebuilding
./scripts/dev-workflow.sh check
```

### 2.2. Build Commands
```bash
# Build development version of specific service
./scripts/dev-workflow.sh build dev <service_name>

# Incremental build using cache optimization (all services)
./scripts/dev-workflow.sh incremental

# Clean build (only when absolutely necessary)
./scripts/dev-workflow.sh build clean <service_name>
```

### 2.3. Monitoring and Debugging
```bash
# View development logs
docker-compose -f docker-compose.yml -f docker-compose.dev.yml logs -f <service_name>

# Check container status
docker ps | grep huleedu

# Access container shell for debugging
docker exec -it huleedu_<service_name> /bin/bash
```

## 3. Multi-Stage Dockerfile Architecture

### 3.1. Required Dockerfile.dev Structure
```dockerfile
# Multi-stage development-optimized Dockerfile
FROM python:3.11-slim as base

ENV PYTHONUNBUFFERED=1 \
    PYTHONDONTWRITEBYTECODE=1 \
    PDM_USE_VENV=false \
    ENV_TYPE=docker \
    PYTHONPATH=/app

# Install system dependencies (rarely change - good cache layer)
RUN apt-get update && apt-get install -y \
    --no-install-recommends \
    curl \
    build-essential \
    python3-dev \
    && rm -rf /var/lib/apt/lists/*

# Install PDM (rarely changes - good cache layer)
RUN pip install --no-cache-dir pdm

WORKDIR /app

# ========================================
# DEPENDENCY INSTALLATION OPTIMIZATION
# ========================================

# Copy only dependency files for better caching
COPY libs/common_core/pyproject.toml /app/libs/common_core/pyproject.toml
COPY libs/huleedu_service_libs/pyproject.toml /app/libs/huleedu_service_libs/pyproject.toml
COPY services/<service_name>/pyproject.toml /app/services/<service_name>/pyproject.toml

# Generate lockfile if it doesn't exist
WORKDIR /app/services/<service_name>
RUN pdm lock --lockfile pdm.lock.docker || echo "Lock generation failed, will install without lock"

# Copy shared library source files
COPY libs/common_core/src/ /app/libs/common_core/src/
COPY libs/huleedu_service_libs/src/ /app/libs/huleedu_service_libs/src/

# Install dependencies using lockfile if available
RUN if [ -f "pdm.lock.docker" ]; then \
        pdm install --prod --lockfile pdm.lock.docker; \
    else \
        pdm install --prod; \
    fi

# ========================================
# DEVELOPMENT STAGE (for volume mounts)
# ========================================
FROM base as development

# Create application user and directories
RUN groupadd -r appuser && useradd --no-log-init -r -g appuser appuser

# Copy service code (this layer changes most frequently)
COPY services/<service_name>/ /app/services/<service_name>/

# Set permissions
RUN chown -R appuser:appuser /app

USER appuser
WORKDIR /app/services/<service_name>

CMD ["pdm", "run", "start"]

# ========================================
# PRODUCTION STAGE (for deployment)
# ========================================
FROM base as production

# Copy service code for production build
COPY services/<service_name>/ /app/services/<service_name>/

# Create user and set permissions
RUN groupadd -r appuser && useradd --no-log-init -r -g appuser appuser \
    && chown -R appuser:appuser /app

USER appuser
WORKDIR /app/services/<service_name>

CMD ["pdm", "run", "start"]
```

### 3.2. Layer Caching Strategy
1. **System dependencies**: Rarely change, cached longest
2. **PDM installation**: Cached per Python version
3. **Dependency files**: Change only when dependencies update
4. **Shared library source**: Change more frequently than dependencies
5. **Service code**: Changes most frequently, shortest cache

## 4. Development Compose Configuration

### 4.1. docker-compose.dev.yml Structure
```yaml
# Development-optimized Docker Compose with volume mounts for hot-reload
services:
  service_name:
    build:
      context: .
      dockerfile: services/<service_name>/Dockerfile.dev
      target: development
    volumes:
      # Mount source code for hot-reload
      - ./services/<service_name>:/app/services/<service_name>:cached
      - ./libs/common_core/src:/app/libs/common_core/src:cached
      - ./libs/huleedu_service_libs/src:/app/libs/huleedu_service_libs/src:cached
      # Exclude build artifacts
      - /app/services/<service_name>/__pycache__
      - /app/services/<service_name>/__pypackages__
    environment:
      - ENV_TYPE=development
      - LOG_LEVEL=DEBUG
```

### 4.2. Volume Mount Strategy
- **Source code**: Hot-reload via cached volume mounts
- **Shared libraries**: Mounted for cross-service development
- **Build artifacts**: Excluded to prevent conflicts
- **Dependencies**: Installed in container for performance

## 5. Service-Specific Optimizations

### 5.1. HTTP Services (Quart/FastAPI)
- Expose service ports for external access
- Include health check endpoints
- Support both API and worker modes where applicable

### 5.2. Worker Services (Kafka consumers)
- No port exposure required
- Focus on logging and monitoring
- Support graceful shutdown signals

### 5.3. Hybrid Services (API + Worker)
- Support multiple command modes via CMD override
- Example: `essay_lifecycle_service` with API and worker components

## 6. Build Optimization Rules

### 6.1. MUST Requirements
- **Dependencies before code**: Always copy pyproject.toml before source code
- **Multi-stage builds**: Use base → development → production stages
- **Dynamic lockfiles**: Generate lockfiles in container for flexibility
- **Layer separation**: Separate frequently changing from stable layers

### 6.2. MUST NOT Requirements
- **NEVER use --no-cache** for development builds
- **NEVER copy source code before dependencies**
- **NEVER install dependencies in final stage only**
- **NEVER skip volume mounts for development services**

## 7. Performance Monitoring

### 7.1. Build Time Targets
- **Development builds**: < 10 seconds (first time may be longer)
- **Incremental builds**: 4-6 seconds
- **Cache hit rate**: > 95% for dependency layers

### 7.2. Development Experience Targets
- **Code change to reflection**: < 3 seconds
- **Service restart time**: < 30 seconds
- **Full environment startup**: < 2 minutes

## 8. Troubleshooting

### 8.1. Common Issues
- **Build failures**: Check PDM lockfile generation
- **Mount issues**: Verify volume paths and permissions
- **Cache misses**: Ensure dependency files copied before source code
- **Permission errors**: Check user/group setup in Dockerfile

### 8.2. Debug Commands
```bash
# Check build context and cache usage
docker build --progress=plain -f services/<service>/Dockerfile.dev .

# Inspect image layers
docker history <image_name>

# Check volume mounts
docker inspect huleedu_<service_name> | grep -A 10 "Mounts"
```

## 9. Implementation Status

### 9.1. Optimized Services
- ✅ nlp_service
- ✅ batch_orchestrator_service
- ✅ essay_lifecycle_service (API + worker)
- ✅ spellchecker_service
- ✅ file_service
- ✅ content_service

### 9.2. Template for Remaining Services
Use the Dockerfile.dev template above to optimize remaining services:
- class_management_service
- batch_conductor_service
- llm_provider_service
- api_gateway_service
- result_aggregator_service
- websocket_service
- cj_assessment_service

### 9.3. Implementation Checklist
- [ ] Create `Dockerfile.dev` with multi-stage pattern
- [ ] Add service to `docker-compose.dev.yml`
- [ ] Test development build: `./scripts/dev-workflow.sh build dev <service>`
- [ ] Verify hot-reload: Make code change and check logs
- [ ] Validate performance: Measure build times