---
description: HuleEdu Service Libraries - shared Kafka, Redis, logging, observability, resilience components
globs: 
alwaysApply: false
---

# 020.11: Service Libraries Architecture

## Package Identity
- **Location**: `libs/huleedu_service_libs/`
- **Package**: `huleedu-service-libs`
- **Consumers**: All HuleEdu services (11 services)

## Core Components

| Component | Purpose | Key Methods |
|-----------|---------|-------------|
| `KafkaBus` | Async Kafka producer | `start()`, `stop()`, `publish_event()` |
| `RedisClient` | Key-value ops, atomic transactions | `set_if_not_exists()`, `watch()`, `multi()`, `exec()` |
| `RedisPubSub` | Pub/sub operations | `publish()`, `subscribe()`, `get_user_channel()` |
| `DatabaseHealthChecker` | PostgreSQL monitoring | `check_basic_connectivity()`, `get_health_summary()` |
| `@idempotent_consumer` | Duplicate message prevention | Decorates Kafka consumers |
| `OutboxManager` | Transactional event publishing | Shared across all services |

## Integration Patterns

### Redis Client DI
```python
@provide(scope=Scope.APP)
async def provide_redis_client(self, settings: Settings) -> AsyncGenerator[AtomicRedisClientProtocol, None]:
    redis_client = RedisClient(client_id=f"{settings.SERVICE_NAME}-redis", redis_url=settings.REDIS_URL)
    await redis_client.start()
    try:
        yield redis_client
    finally:
        await redis_client.stop()
```

### Kafka Client DI
```python
@provide(scope=Scope.APP)
async def provide_kafka_bus(self, settings: Settings) -> AsyncGenerator[KafkaPublisherProtocol, None]:
    base_kafka_bus = KafkaBus(client_id=settings.PRODUCER_CLIENT_ID, bootstrap_servers=settings.KAFKA_BOOTSTRAP_SERVERS)
    await base_kafka_bus.start()
    try:
        # Optional circuit breaker protection
        yield ResilientKafkaPublisher(base_kafka_bus, kafka_circuit_breaker) if settings.CIRCUIT_BREAKER_ENABLED else base_kafka_bus
    finally:
        await base_kafka_bus.stop()
```

### OutboxManager Integration
```python
# Pattern A: Direct Provider (Recommended)
@provide(scope=Scope.APP)
def provide_outbox_manager(self, outbox_repository: OutboxRepositoryProtocol, redis_client: AtomicRedisClientProtocol, settings: Settings) -> OutboxManager:
    return OutboxManager(outbox_repository=outbox_repository, redis_client=redis_client, service_name=settings.SERVICE_NAME)

# Pattern B: OutboxProvider
return make_async_container(CoreProvider(), ServiceProvider(), OutboxProvider())
```

## Required Usage Patterns

### Redis Operations
- **MUST** call `start()` before use, `stop()` on shutdown
- **MUST** use `set_if_not_exists()` for idempotency keys
- **MUST** use `publish_user_notification()` for WebSocket backplane

### Kafka Operations  
- **MUST** serialize EventEnvelope to JSON
- **MUST** wrap all consumers with `@idempotent_consumer`
- **MUST** handle producer errors without crashing
- **MUST** use deterministic event IDs from message content

### Database Operations
- **MUST** call `setup_database_monitoring()` for PostgreSQL services
- **MUST** store DatabaseHealthChecker on app for health endpoints
- **MUST** use `@query_performance_tracker` for critical queries

### Outbox Pattern
- **MUST** use shared `OutboxManager` (all 11 services)
- **MUST** include EventOutbox table schema: `id`, `aggregate_id`, `aggregate_type`, `event_type`, `event_data`, `event_key`, `topic`, `created_at`, `published_at`, `retry_count`, `last_error`
- **MUST** start EventRelayWorker in application lifecycle
- **MUST** share database session between business logic and outbox operations

### Observability
- **MUST** apply `setup_standard_service_metrics_middleware(app, service_name)` to all services
- **MUST** use `create_service_logger(name)` for structured JSON logging
- **MUST** use consistent label naming: `method`, `endpoint`, `status`
- **MUST** integrate circuit breaker metrics via `StandardCircuitBreakerMetrics`

### Framework-Specific Middleware
```python
# Quart services
from huleedu_service_libs.middleware.frameworks.quart_middleware import setup_tracing_middleware

# FastAPI services  
from huleedu_service_libs.middleware.frameworks.fastapi_middleware import setup_tracing_middleware
```

## Protocols

| Protocol | Purpose | Usage |
|----------|---------|-------|
| `RedisClientProtocol` | Basic Redis operations | Testing, DI |
| `AtomicRedisClientProtocol` | Extended with transactions | Production Redis operations |
| `KafkaPublisherProtocol` | Event publishing interface | Testing, circuit breaker wrapping |
| `OutboxRepositoryProtocol` | Outbox database operations | Repository pattern |

## Circuit Breaker Integration
- **CircuitBreaker**: Configurable failure thresholds
- **CircuitBreakerRegistry**: Centralized management
- **Typed Wrappers**: `CircuitBreakerHttpClient`, `CircuitBreakerContentServiceClient`
- **Pattern**: Wrap HTTP clients, Kafka producers, external APIs via DI

## Error Handling
- **ErrorContext**: Rich error context with trace information
- **Pattern**: Use with `huleedu_service_libs.error_handling` factories
- **Integration**: Automatic correlation ID propagation

## Testing Patterns
- **MUST** use `AsyncMock(spec=Protocol)` for testing
- **MUST** mock at protocol level, not implementation
- **Redis/Kafka**: Use testcontainers for integration tests
- **Outbox**: Use testcontainers for PostgreSQL and Kafka testing
- **Idempotency**: Fail-open design - process if Redis unavailable

## Directory Structure
```
libs/huleedu_service_libs/src/huleedu_service_libs/
├── kafka_client.py, redis_client.py, redis_pubsub.py
├── logging_utils.py, metrics_middleware.py, event_utils.py, idempotency_v2.py
├── protocols.py, py.typed
├── database/{health_checks.py, metrics.py, query_monitoring.py}
├── middleware/frameworks/{quart_middleware.py, fastapi_middleware.py}
├── observability/tracing.py
├── resilience/{circuit_breaker.py, registry.py, http_client.py, content_service.py}
├── error_handling/factories.py
└── outbox/{manager.py, models.py, protocols.py, repository.py, relay.py, monitoring.py, di.py}
```

## Lifecycle Management
- **MUST** use explicit `start()` and `stop()` methods
- **MUST** manage via DI containers or startup hooks
- **MUST** ensure proper async resource cleanup
- **Pattern**: Protocol-based design enables clean mocking and multiple implementations
