---
description: Result Aggregator Service (RAS) - CQRS read model for aggregated processing results
globs:
  - services/result_aggregator_service/**
---

# 020.12: Result Aggregator Service Architecture

## Service Identity

- **Type**: Hybrid (Kafka Consumer + HTTP API)
- **Pattern**: CQRS with event sourcing and materialized views
- **Persistence**: PostgreSQL (dedicated database)
- **Cache**: Redis for query optimization

## Core Responsibilities

1. **Event Aggregation**: Consume completion events from all processing services
2. **Read Model Maintenance**: Build and maintain queryable aggregated state
3. **Query API**: Provide fast, optimized access to batch and essay results
4. **Cache Management**: Optimize read performance via strategic caching

## Event Contracts

### Consumes

```python
# Initial batch registration
topic_name(ProcessingEvent.BATCH_ESSAYS_REGISTERED)  # Create initial batch records

# Processing completion events
"huleedu.els.batch_phase.outcome.v1"     # Phase completion outcomes
"huleedu.essay.spellcheck.completed.v1"  # Spellcheck results
"huleedu.cj_assessment.completed.v1"     # CJ assessment rankings
```

### Produces

None - Pure read model (CQRS command/query separation)

## API Contracts

### Internal Endpoints

```python
# Batch status query
GET /internal/v1/batches/{batch_id}/status
Response: BatchStatusResponse (includes user_id for security validation)

# User batches query  
GET /internal/v1/batches/user/{user_id}?limit=20&offset=0&status=COMPLETED
Response: Paginated list of BatchStatusResponse
```

### Authentication

- Service-to-service via `X-Internal-API-Key` and `X-Service-ID` headers
- Whitelist: API Gateway Service, Admin Dashboard Service

## Database Schema

### Tables

1. **batch_results**: Batch-level aggregation
   - Uses `BatchStatus` from `common_core.status_enums`
   - Tracks overall progress and metadata

2. **essay_results**: Essay-level phase results
   - Uses `ProcessingStage` from `common_core.enums`
   - Stores phase-specific results (corrections, rankings, etc.)

### Key Patterns

- Foreign key from essay_results to batch_results
- Composite indexes on (user_id, batch_id) for query optimization
- Status enums directly from common_core (no local duplicates)

## Architectural Patterns

### Event Processing

```python
# Idempotent consumer with 24-hour TTL
@idempotent_consumer(redis_client=redis_client, ttl_seconds=86400)
async def process_message_idempotently(msg: ConsumerRecord) -> bool:
    # Process with automatic deduplication
```

### Caching Abstraction

```python
class CacheManagerProtocol(Protocol):
    # Single-entity caching
    async def get_batch_status_json(self, batch_id: str) -> Optional[str]: ...
    async def set_batch_status_json(self, batch_id: str, status_json: str, ttl: int) -> None: ...
    
    # List/pagination caching with active invalidation
    async def get_user_batches_json(
        self, user_id: str, limit: int, offset: int, status: Optional[str]
    ) -> Optional[str]: ...
    async def set_user_batches_json(
        self, user_id: str, limit: int, offset: int, status: Optional[str], 
        data_json: str, ttl: int
    ) -> None: ...
    
    # Active cache invalidation
    async def invalidate_user_batches(self, user_id: str) -> None: ...
    async def invalidate_batch(self, batch_id: str) -> None: ...
```

### Repository Pattern

All database operations through `BatchRepositoryProtocol`:
- `create_batch()`: Initialize from registration event
- `update_essay_*_result()`: Update phase-specific results
- `get_batch()`: Retrieve with eager-loaded essays

## Critical Implementation Details

1. **Batch Initialization**: Must subscribe to `BATCH_ESSAYS_REGISTERED` to create initial records
2. **Enum Consistency**: All status fields use common_core enums directly
3. **Cache Key Patterns**:
   - Single batch: `ras:batch:{batch_id}`
   - User batches: `ras:user:{user_id}:batches:{limit}:{offset}:{status}`
   - User tracking: `ras:user:{user_id}:cache_keys` (Redis SET for invalidation)
4. **No Event Production**: Service only consumes, never produces events
5. **Error Resilience**: Production-grade consumer handles poison pills gracefully
6. **Active Cache Invalidation**: Redis SET-based tracking eliminates KEYS/SCAN operations

## Integration Points

- **API Gateway**: Primary consumer via internal API
- **Processing Services**: Event sources for aggregation
- **Redis**: Shared infrastructure for caching and idempotency

## Performance Characteristics

- Query optimization via materialized views
- API response caching (5-minute TTL)
- Batch event processing for efficiency
- Connection pooling for database operations
- Active cache invalidation via Redis SETs (no expensive KEYS operations)
- Atomic cache operations using Redis pipelines
- Poison pill storage with metrics for monitoring malformed messages
