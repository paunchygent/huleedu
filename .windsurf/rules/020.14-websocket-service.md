---
description: Defines the WebSocket Service. Handles real-time bidirectional communication between clients and the HuleEdu platform.
globs: 
alwaysApply: false
---
# 020.14: WebSocket Service Architecture

## 1. Service Identity
- **Package**: `huleedu-websocket-service`
- **Folders**: `services/websocket_service/`
- **Port**: 8081 (external), 8080 (internal Docker)
- **Stack**: FastAPI, Uvicorn, Dishka, `PyJWT` (for JWT), Redis (for pub/sub)
- **Purpose**: Dedicated service for handling WebSocket connections, providing real-time notifications and updates to connected clients.

## 2. Core Architectural Patterns

The WebSocket service provides real-time communication capabilities, acting as a bridge between the event-driven backend and connected clients.

### 2.1. Authentication
- **Mechanism**: JWT authentication via query parameter
- **Endpoint**: `ws://<host>/ws/v1/status/{client_id}?token=<jwt_token>`
- **Validation**: 
    1. Extracts token from query parameter (required for WebSocket connections)
    2. Validates JWT signature and expiration
    3. Extracts user ID from the `sub` claim
    4. Ensures client can only subscribe to their own notifications

### 2.2. Redis Pub/Sub Bridge
- **Architecture**: Implements a Redis subscription model for each authenticated user
- **Flow**:
    1. Client connects via WebSocket with valid JWT token
    2. Service subscribes to user-specific Redis channel: `ws:{user_id}`
    3. Concurrent `redis_listener` task monitors the channel for messages
    4. Backend services publish notifications via `RedisClient.publish_user_notification`
    5. Listener forwards messages to the client over the WebSocket connection
    6. Connection lifecycle management ensures proper cleanup on disconnect

### 2.3. Message Format
- **Inbound**: Currently supports simple text messages (future: structured commands)
- **Outbound**: JSON-formatted notification payloads from backend services
- **Example Notification**:
    ```json
    {
        "event_type": "batch.status.updated",
        "batch_id": "uuid-here",
        "status": "completed",
        "timestamp": "2025-01-18T10:30:00Z"
    }
    ```

## 3. Integration Points

### 3.1. Redis Integration
- **Purpose**: Central message broker for real-time notifications
- **Channels**: User-specific channels following pattern `ws:{user_id}`
- **Publishers**: Any backend service can publish notifications via common_core's RedisClient

### 3.2. Service Communication
- **No Direct Service Calls**: WebSocket service is notification-only
- **Event-Driven**: Receives updates through Redis pub/sub, not direct API calls
- **Stateless**: No persistent state beyond active connections

## 4. Connection Management

### 4.1. Lifecycle
1. **Connection**: Client connects with JWT token in query string
2. **Authentication**: Token validated, user_id extracted
3. **Subscription**: Redis listener started for user's channel
4. **Active**: Bidirectional communication enabled
5. **Disconnection**: Cleanup of Redis subscription and resources

### 4.2. Error Handling
- **Invalid Token**: Connection rejected with appropriate WebSocket close code
- **Redis Failures**: Graceful degradation with client notification
- **Unexpected Disconnects**: Automatic cleanup of resources

## 5. Scalability Considerations

- **Horizontal Scaling**: Multiple WebSocket service instances can run behind a load balancer
- **Sticky Sessions**: Required for WebSocket connections in multi-instance deployments
- **Redis Clustering**: Supports Redis cluster mode for high availability
- **Connection Limits**: Configurable per-instance connection limits for resource management
