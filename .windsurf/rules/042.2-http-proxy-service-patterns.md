---
description: HTTP proxy patterns for API gateway and service-to-service communication
globs: ["**/routers/*_routes.py", "**/api/*_routes.py"]
alwaysApply: false
---

# 042.2: HTTP Proxy Service Patterns

## Core Proxy Patterns

### Complete Service Proxy
```python
@router.api_route("/{path:path}", methods=["GET", "POST", "PUT", "DELETE"])
async def proxy_requests(path: str, request: Request, http_client: FromDishka[AsyncClient], metrics: FromDishka[ServiceMetrics]):
    """Proxies all requests to downstream service."""
    url = f"{settings.DOWNSTREAM_SERVICE_URL}/v1/{path}"
    endpoint = f"/{path}"
    
    with metrics.http_request_duration_seconds.labels(method=request.method, endpoint=endpoint).time():
        try:
            # Prepare request headers
            headers = dict(request.headers)
            headers.pop("host", None)  # Let httpx set the host
            
            with metrics.downstream_service_call_duration_seconds.labels(
                service="downstream_service", method=request.method, endpoint=f"/v1/{path}"
            ).time():
                req = http_client.build_request(method=request.method, url=url, headers=headers, 
                                              params=request.query_params, content=request.stream())
                response = await http_client.send(req, stream=True)
            
            # Record metrics
            metrics.downstream_service_calls_total.labels(
                service="downstream_service", method=request.method, 
                endpoint=f"/v1/{path}", status_code=str(response.status_code)
            ).inc()
            
            return StreamingResponse(response.aiter_raw(), status_code=response.status_code, headers=response.headers)
            
        except Exception as e:
            logger.error(f"Proxy error for {request.method} {endpoint}: {e}", exc_info=True)
            metrics.api_errors_total.labels(endpoint=endpoint, error_type="proxy_error").inc()
            raise
```

### Identity-Enriched Proxy (API Gateway)
```python
from huleedu_service_libs.error_handling.correlation import CorrelationContext
from dishka import FromDishka

@router.post("/v1/batches/register")
async def register_batch(
    registration_request: ClientRegistrationModel,  # no identity fields
    http_client: FromDishka[HttpClientProtocol],
    user_id: FromDishka[str],
    org_id: FromDishka[str | None],
    corr: FromDishka[CorrelationContext],
):
    # Build shared HTTP contract from common_core
    internal = BatchRegistrationRequestV1(**registration_request.model_dump(), user_id=user_id, org_id=org_id)

    # Proxy to downstream with correlation header
    response = await http_client.post(
        f"{settings.BOS_URL}/v1/batches/register",
        json=internal.model_dump(mode="json"),
        headers={"X-Correlation-ID": corr.original},  # Use original for header
    )
    # Preserve downstream status and body
    return JSONResponse(status_code=response.status_code, content=response.json())
```

**Key Points:**
- Extract identity once at edge via DI providers (`user_id`, optional `org_id`)
- Use shared HTTP contracts from `common_core.api_models` for inter-service requests
- Forward `X-Correlation-ID` and identity headers where relevant
- Preserve downstream response semantics using framework response objects

## Header Management

### Header Transformation Rules

| Rule | Action | Headers |
|------|--------|---------|
| **MUST** remove | Avoid conflicts | `host`, `content-length` |
| **SHOULD** forward | Identity tracking | `X-User-ID`, `X-Org-ID`, `X-Correlation-ID`, `X-Request-ID` |
| **MAY** add | Service identification | `X-Proxied-By` |

### Header Preparation Pattern
```python
def prepare_proxy_headers(original_headers: Headers, correlation_id: str) -> dict[str, str]:
    """Prepare headers for downstream service call."""
    headers = dict(original_headers)
    
    # Remove problematic headers
    headers.pop("host", None)
    headers.pop("content-length", None)  # Let httpx handle this
    
    # Add correlation tracking
    if "x-correlation-id" not in headers:
        headers["X-Correlation-ID"] = correlation_id
    
    # Add proxy identification
    headers["X-Proxied-By"] = "api-gateway-service"
    
    return headers
```

## Error Handling Patterns

### Error Response Mapping

| Error Type | HTTP Status | Action |
|-----------|-------------|---------|
| 4xx client errors | Forward as-is | Minimal transformation |
| 5xx server errors | 503 Service Unavailable | Log for debugging, return generic |
| Network errors | 503 Service Unavailable | Connection/timeout issues |
| Timeout errors | 504 Gateway Timeout | Downstream timeout |

### Error Handler Pattern
```python
try:
    response = await http_client.request(...)
    response.raise_for_status()
    return response.json()
except httpx.TimeoutException:
    metrics.api_errors_total.labels(endpoint=endpoint, error_type="timeout").inc()
    raise HTTPException(status_code=504, detail="Gateway timeout")
except httpx.ConnectError:
    metrics.api_errors_total.labels(endpoint=endpoint, error_type="connection_error").inc()
    raise HTTPException(status_code=503, detail="Service unavailable")
except httpx.HTTPStatusError as e:
    if 400 <= e.response.status_code < 500:
        raise HTTPException(status_code=e.response.status_code, detail=e.response.text)  # Forward client errors
    else:
        metrics.api_errors_total.labels(endpoint=endpoint, error_type="downstream_error").inc()
        raise HTTPException(status_code=503, detail="Downstream service error")  # Mask server errors
```

## Required Metrics

| Metric | Purpose | Labels |
|--------|---------|---------|
| `http_requests_total` | Total requests to proxy endpoint | `method`, `endpoint`, `http_status` |
| `http_request_duration_seconds` | Proxy endpoint latency | `method`, `endpoint` |
| `downstream_service_calls_total` | Calls to downstream service | `service`, `method`, `endpoint`, `status_code` |
| `downstream_service_call_duration_seconds` | Downstream service latency | `service`, `method`, `endpoint` |
| `api_errors_total` | Error categorization | `endpoint`, `error_type` |

## Performance Requirements

### Connection Management
- **MUST** use shared `httpx.AsyncClient` via DI (connection pooling)
- **MUST** configure appropriate timeouts for downstream services
- **SHOULD** implement retry logic for transient failures

### Response Handling
- **Use StreamingResponse** for large payloads or preserving exact responses
- **Use JSON transformation** for small payloads requiring modification
- **Consider memory implications** for file upload/download proxying

## Security Requirements

### Authorization
- **MUST** validate authorization at gateway boundary (JWT validation in AGW)
- **SHOULD** add service-to-service authentication headers where required by downstreams
- **FORBIDDEN** Exposing internal service authentication tokens to clients

### Input Validation
- **MUST** validate proxy path parameters to prevent SSRF
- **SHOULD** implement allow-lists for downstream URLs
- **MUST** sanitize headers to prevent header injection

## Testing Requirements

### Mock Downstream Services
```python
@pytest.mark.asyncio
async def test_proxy_endpoint(client: AsyncClient, respx_mock: MockRouter):
    """Test proxy functionality with mocked downstream service."""
    downstream_url = f"{settings.DOWNSTREAM_SERVICE_URL}/v1/endpoint"
    mock_route = respx_mock.get(downstream_url).mock(return_value=Response(200, json={"result": "success"}))
    
    response = await client.get("/v1/proxy/endpoint")
    
    assert response.status_code == 200
    assert response.json() == {"result": "success"}
    assert mock_route.called
```

### Test Coverage Requirements
- **MUST** test successful proxy calls
- **MUST** test downstream service error responses (4xx, 5xx)
- **MUST** test network error scenarios  
- **MUST** test identity injection behavior (user_id and org_id flows)
- **SHOULD** test header forwarding behavior
- **SHOULD** test request/response transformation if applicable

## Logging Standards
- **MUST** log proxy request initiation with correlation ID
- **MUST** log downstream service errors with full context
- **SHOULD** log successful proxy completion with timing
- **FORBIDDEN** Logging sensitive data from requests/responses

## Implementation Pattern
**Best Practice**: Start with complete service proxy pattern, then specialize as needed.
