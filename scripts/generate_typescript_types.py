#!/usr/bin/env python3
"""
Script to generate TypeScript types from OpenAPI specification.

This script reads the generated OpenAPI spec and creates TypeScript
interface definitions for frontend development.
"""

import json
import sys
from pathlib import Path
from typing import Any, Dict

# Add the project root to Python path
project_root = Path(__file__).parent.parent
sys.path.insert(0, str(project_root))


def python_type_to_typescript(schema: Dict[str, Any], definitions: Dict[str, Any] = None) -> str:
    """Convert OpenAPI schema to TypeScript type."""
    if definitions is None:
        definitions = {}

    schema_type = schema.get("type")

    if schema_type == "string":
        if "enum" in schema:
            enum_values = " | ".join(f'"{val}"' for val in schema["enum"])
            return enum_values
        return "string"
    elif schema_type == "integer" or schema_type == "number":
        return "number"
    elif schema_type == "boolean":
        return "boolean"
    elif schema_type == "array":
        items = schema.get("items", {})
        item_type = python_type_to_typescript(items, definitions)
        return f"{item_type}[]"
    elif schema_type == "object":
        if "additionalProperties" in schema:
            if schema["additionalProperties"] is True:
                return "Record<string, any>"
            else:
                prop_type = python_type_to_typescript(schema["additionalProperties"], definitions)
                return f"Record<string, {prop_type}>"

        properties = schema.get("properties", {})
        required = set(schema.get("required", []))

        if not properties:
            return "Record<string, any>"

        props = []
        for prop_name, prop_schema in properties.items():
            prop_type = python_type_to_typescript(prop_schema, definitions)
            optional = "" if prop_name in required else "?"
            props.append(f"  {prop_name}{optional}: {prop_type}")

        return "{\n" + ";\n".join(props) + "\n}"

    # Handle references
    if "$ref" in schema:
        ref_path = schema["$ref"]
        if ref_path.startswith("#/components/schemas/"):
            type_name = ref_path.split("/")[-1]
            return type_name

    # Handle anyOf/oneOf
    if "anyOf" in schema:
        types = [python_type_to_typescript(s, definitions) for s in schema["anyOf"]]
        return " | ".join(types)

    if "oneOf" in schema:
        types = [python_type_to_typescript(s, definitions) for s in schema["oneOf"]]
        return " | ".join(types)

    # Default fallback
    return "any"


def generate_typescript_interfaces(openapi_spec: Dict[str, Any]) -> str:
    """Generate TypeScript interfaces from OpenAPI specification."""

    ts_content = [
        "// Generated TypeScript types from HuleEdu API Gateway OpenAPI specification",
        "// Do not edit this file manually - regenerate using scripts/generate_typescript_types.py",
        "",
        "// ============================================================================",
        "// API Response Types",
        "// ============================================================================",
        "",
    ]

    # Extract schemas from components
    components = openapi_spec.get("components", {})
    schemas = components.get("schemas", {})

    # Generate interfaces for schemas
    for schema_name, schema_def in schemas.items():
        ts_type = python_type_to_typescript(schema_def, schemas)
        ts_content.extend([f"export interface {schema_name} {ts_type}", ""])

    # Generate endpoint types
    ts_content.extend(
        [
            "// ============================================================================",
            "// API Endpoint Types",
            "// ============================================================================",
            "",
        ]
    )

    paths = openapi_spec.get("paths", {})

    for path, methods in paths.items():
        for method, operation in methods.items():
            if method.upper() not in ["GET", "POST", "PUT", "DELETE", "PATCH"]:
                continue

            operation_id = operation.get("operationId", "").replace("_", "")

            # Request body type
            request_body = operation.get("requestBody")
            if request_body:
                content = request_body.get("content", {})
                for content_type, content_schema in content.items():
                    if "application/json" in content_type:
                        schema = content_schema.get("schema", {})
                        req_type = python_type_to_typescript(schema, schemas)
                        ts_content.extend(
                            [f"export interface {operation_id}Request {req_type}", ""]
                        )

            # Response types
            responses = operation.get("responses", {})
            for status_code, response in responses.items():
                if status_code == "200":
                    content = response.get("content", {})
                    for content_type, content_schema in content.items():
                        if "application/json" in content_type:
                            schema = content_schema.get("schema", {})
                            resp_type = python_type_to_typescript(schema, schemas)
                            ts_content.extend(
                                [f"export interface {operation_id}Response {resp_type}", ""]
                            )

    # Add common API types
    ts_content.extend(
        [
            "// ============================================================================",
            "// Common API Types",
            "// ============================================================================",
            "",
            "export interface ApiError {",
            "  detail: string;",
            "  status_code?: number;",
            "  correlation_id?: string;",
            "}",
            "",
            "export interface ApiResponse<T> {",
            "  data?: T;",
            "  error?: ApiError;",
            "  success: boolean;",
            "}",
            "",
            "// Authentication types",
            "export interface JWTToken {",
            "  access_token: string;",
            "  token_type: string;",
            "  expires_in?: number;",
            "}",
            "",
            "export interface AuthHeaders {",
            "  Authorization: string;",
            "  'X-Correlation-ID'?: string;",
            "}",
            "",
            "// WebSocket types",
            "export interface WebSocketMessage {",
            "  type: string;",
            "  data: any;",
            "  timestamp: string;",
            "}",
            "",
            "export interface TeacherNotification {",
            "  teacher_id: string;",
            "  notification_type: string;",
            "  category: 'BATCH_PROCESSING' | 'CLASS_MANAGEMENT' | 'SYSTEM_ALERT' | 'USER_ACTION';",
            "  priority: 'LOW' | 'STANDARD' | 'HIGH' | 'IMMEDIATE';",
            "  payload: Record<string, any>;",
            "  action_required: boolean;",
            "  correlation_id: string;",
            "  batch_id?: string;",
            "  class_id?: string;",
            "  timestamp: string;",
            "}",
            "",
        ]
    )

    return "\n".join(ts_content)


def generate_typescript_types():
    """Generate TypeScript types from OpenAPI specification."""
    try:
        # Read the OpenAPI specification
        spec_file = project_root / "docs" / "api-gateway-openapi.json"
        if not spec_file.exists():
            print(f"‚ùå OpenAPI specification not found at {spec_file}")
            print("üí° Run scripts/generate_openapi_spec.py first")
            return False

        with open(spec_file, "r", encoding="utf-8") as f:
            openapi_spec = json.load(f)

        # Generate TypeScript content
        ts_content = generate_typescript_interfaces(openapi_spec)

        # Save TypeScript types
        types_file = project_root / "docs" / "api-types.ts"
        with open(types_file, "w", encoding="utf-8") as f:
            f.write(ts_content)

        print("‚úÖ TypeScript types generated successfully!")
        print(f"üìÑ Saved to: {types_file}")

        # Count generated interfaces
        interface_count = ts_content.count("export interface")
        print(f"üìä Generated {interface_count} TypeScript interfaces")

        return True

    except Exception as e:
        print(f"‚ùå Error generating TypeScript types: {e}")
        return False


if __name__ == "__main__":
    success = generate_typescript_types()
    sys.exit(0 if success else 1)
