"""SHAP explainability utilities for essay scoring models."""

from __future__ import annotations

from collections.abc import Callable
from dataclasses import dataclass
from pathlib import Path
from typing import Protocol

import matplotlib
import numpy as np
import xgboost as xgb

matplotlib.use("Agg")

from matplotlib import pyplot as plt


@dataclass(frozen=True)
class ShapArtifacts:
    """Artifacts generated by SHAP explainability."""

    shap_values_path: Path
    base_values_path: Path
    summary_plot_path: Path
    bar_plot_path: Path


class TreeExplainerProtocol(Protocol):
    expected_value: float | np.ndarray

    def shap_values(self, features: np.ndarray) -> np.ndarray: ...


class SummaryPlotProtocol(Protocol):
    def __call__(
        self,
        shap_values: np.ndarray,
        features: np.ndarray,
        *,
        feature_names: list[str],
        show: bool,
        plot_type: str | None = None,
    ) -> None: ...


def _default_explainer_factory(model: xgb.Booster) -> TreeExplainerProtocol:
    import shap

    return shap.TreeExplainer(model)


def _default_summary_plot(
    shap_values: np.ndarray,
    features: np.ndarray,
    *,
    feature_names: list[str],
    show: bool,
    plot_type: str | None = None,
) -> None:
    import shap

    kwargs: dict[str, object] = {"feature_names": feature_names, "show": show}
    if plot_type is not None:
        kwargs["plot_type"] = plot_type
    shap.summary_plot(shap_values, features, **kwargs)


def generate_shap_artifacts(
    model: xgb.Booster,
    features: np.ndarray,
    feature_names: list[str],
    output_dir: Path,
    max_samples: int = 500,
    explainer_factory: Callable[[xgb.Booster], TreeExplainerProtocol] | None = None,
    summary_plot_fn: SummaryPlotProtocol | None = None,
) -> ShapArtifacts:
    """Generate SHAP values and summary plots for a model.

    Args:
        model: Trained XGBoost booster.
        features: Feature matrix.
        feature_names: Ordered feature names.
        output_dir: Output directory for artifacts.
        max_samples: Maximum number of samples used for SHAP computation.

    Returns:
        ShapArtifacts containing paths to SHAP outputs.
    """

    output_dir.mkdir(parents=True, exist_ok=True)
    sample_features = _sample_features(features, max_samples=max_samples)

    explainer_factory = explainer_factory or _default_explainer_factory
    summary_plot_fn = summary_plot_fn or _default_summary_plot

    explainer = explainer_factory(model)
    shap_values = explainer.shap_values(sample_features)
    base_values = explainer.expected_value

    shap_values_path = output_dir / "shap_values.npy"
    base_values_path = output_dir / "shap_base_values.npy"
    np.save(shap_values_path, shap_values)
    np.save(base_values_path, np.array(base_values))

    summary_plot_path = output_dir / "shap_summary.png"
    bar_plot_path = output_dir / "shap_summary_bar.png"

    summary_plot_fn(
        shap_values,
        sample_features,
        feature_names=feature_names,
        show=False,
    )
    plt.tight_layout()
    plt.savefig(summary_plot_path)
    plt.close()

    summary_plot_fn(
        shap_values,
        sample_features,
        feature_names=feature_names,
        plot_type="bar",
        show=False,
    )
    plt.tight_layout()
    plt.savefig(bar_plot_path)
    plt.close()

    return ShapArtifacts(
        shap_values_path=shap_values_path,
        base_values_path=base_values_path,
        summary_plot_path=summary_plot_path,
        bar_plot_path=bar_plot_path,
    )


def _sample_features(features: np.ndarray, max_samples: int) -> np.ndarray:
    """Sample feature rows to keep SHAP computation manageable."""

    if features.shape[0] <= max_samples:
        return features
    rng = np.random.default_rng(seed=42)
    indices = rng.choice(features.shape[0], size=max_samples, replace=False)
    return features[indices]
