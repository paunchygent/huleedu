"""
Tests for BOS data propagation functionality.

This module tests how essay lists and data are propagated between processing
phases in the Batch Orchestrator Service (BOS).
"""
from __future__ import annotations

import uuid
from unittest.mock import AsyncMock

import pytest

from common_core.metadata_models import (
    EssayProcessingInputRefV1,
)
from common_core.pipeline_models import (
    PhaseName,
    PipelineExecutionStatus,
    PipelineStateDetail,
    ProcessingPipelineState,
)
from services.batch_orchestrator_service.api_models import (
    BatchRegistrationRequestV1,
)
from services.batch_orchestrator_service.implementations.pipeline_phase_coordinator_impl import (
    DefaultPipelinePhaseCoordinator,
)

# Import all fixtures from shared utilities
pytest_plugins = ("scripts.tests.test_phase3_bos_orchestration_utils",)

pytestmark = pytest.mark.asyncio


class TestBOSDataPropagation:
    """Tests for BOS data propagation between phases."""

    async def test_essay_list_propagation_to_next_phase_command(
        self,
        pipeline_phase_coordinator: DefaultPipelinePhaseCoordinator,
        mock_batch_repo: AsyncMock,
        mock_cj_initiator: AsyncMock,
        sample_batch_id: str,
        sample_correlation_id: uuid.UUID,
        sample_batch_registration_request_cj_enabled: BatchRegistrationRequestV1,
        sample_essay_refs: list[EssayProcessingInputRefV1],
    ) -> None:
        """
        Tests if processed_essays from ELSBatchPhaseOutcomeV1 are passed to the next phase command.
        Current BOS implementation does NOT pass these explicitly to the CJ initiator.
        """
        correlation_id_str = str(sample_correlation_id)
        initial_state = ProcessingPipelineState(
            batch_id=sample_batch_id,
            requested_pipelines=["spellcheck", "cj_assessment"],
            spellcheck=PipelineStateDetail(status=PipelineExecutionStatus.IN_PROGRESS),
        )
        mock_batch_repo.get_batch_context.return_value = (
            sample_batch_registration_request_cj_enabled
        )
        mock_batch_repo.get_processing_pipeline_state.return_value = (
            initial_state.model_dump()
        )

        # This outcome_event_data would come from ELS, containing processed essays
        # However, the current DefaultPipelinePhaseCoordinator doesn't use
        # outcome_event_data.processed_essays when calling the cj_initiator.
        # So, we don't need to construct the full event here.
        # We only care about the call to mock_cj_initiator.initiate_cj_assessment.

        await pipeline_phase_coordinator.handle_phase_concluded(
            batch_id=sample_batch_id,
            completed_phase="spellcheck",
            phase_status="COMPLETED_SUCCESSFULLY",  # Use current implementation's expected status
            correlation_id=correlation_id_str,
        )

        # Assert that initiate_phase was called with correct parameters
        mock_cj_initiator.initiate_phase.assert_called_once_with(
            batch_id=sample_batch_id,
            phase_to_initiate=PhaseName.CJ_ASSESSMENT,
            correlation_id=sample_correlation_id,  # Expected as UUID object, not string
            essays_for_processing=[],  # Empty list when no processed essays provided
            batch_context=sample_batch_registration_request_cj_enabled,
        )

        # To further test the command generated by the initiator if essays_to_process was None:
        # We'd need to inspect the event_publisher mock from within a
        # DefaultCJAssessmentInitiator test.
        # This test focuses on what PipelinePhaseCoordinator passes.
        # If the design intent is for processed_essays to be passed, this reveals the gap.
