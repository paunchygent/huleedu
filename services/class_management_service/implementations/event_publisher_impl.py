"""Event publisher implementation using the transactional outbox pattern."""

from __future__ import annotations

from datetime import UTC, datetime
from typing import TYPE_CHECKING, Any
from uuid import UUID

from common_core.event_enums import ProcessingEvent, topic_name
from common_core.events.envelope import EventEnvelope
from common_core.events.validation_events import StudentAssociationConfirmation, StudentAssociationsConfirmedV1
from huleedu_service_libs.error_handling import raise_external_service_error
from huleedu_service_libs.logging_utils import create_service_logger

if TYPE_CHECKING:
    from services.class_management_service.config import Settings
    from services.class_management_service.implementations.outbox_manager import OutboxManager

from services.class_management_service.protocols import ClassEventPublisherProtocol

logger = create_service_logger("class_management_service.event_publisher")


class DefaultClassEventPublisherImpl(ClassEventPublisherProtocol):
    """Event publisher implementation using TRUE OUTBOX PATTERN."""

    def __init__(
        self,
        outbox_manager: OutboxManager,
        settings: Settings,
    ) -> None:
        self.outbox_manager = outbox_manager
        self.settings = settings

    async def publish_class_event(self, event_envelope: EventEnvelope) -> None:
        """Publish a class management event using the outbox pattern."""
        try:
            # Determine topic from event type
            event_type = event_envelope.event_type
            topic = topic_name(ProcessingEvent(event_type))

            # Extract aggregate information
            aggregate_id = str(event_envelope.correlation_id)
            aggregate_type = "class"

            # Use outbox pattern for reliable delivery
            await self.outbox_manager.publish_to_outbox(
                aggregate_id=aggregate_id,
                aggregate_type=aggregate_type,
                event_type=event_type,
                event_data=event_envelope,
                topic=topic,
            )

            logger.info(
                "Event published via outbox",
                extra={
                    "event_type": event_type,
                    "correlation_id": str(event_envelope.correlation_id),
                    "topic": topic,
                },
            )

        except Exception as e:
            logger.error(
                f"Failed to publish event: {e}",
                extra={
                    "event_type": event_envelope.event_type,
                    "correlation_id": str(event_envelope.correlation_id),
                },
                exc_info=True,
            )
            raise_external_service_error(
                service="class_management_service",
                operation="publish_class_event",
                external_service="outbox",
                message=f"Failed to publish event: {str(e)}",
                correlation_id=event_envelope.correlation_id,
                event_type=event_envelope.event_type,
            )

    async def publish_student_associations_confirmed(
        self,
        batch_id: str,
        class_id: str,
        associations: list[dict[str, Any]],
        timeout_triggered: bool,
        validation_summary: dict[str, int],
        correlation_id: UUID,
    ) -> None:
        """Publish StudentAssociationsConfirmedV1 event to ELS."""
        try:
            # Convert dictionary associations to proper model instances
            association_models = []
            for assoc in associations:
                confirmation = StudentAssociationConfirmation(
                    essay_id=assoc["essay_id"],
                    student_id=assoc.get("student_id"),
                    confidence_score=assoc["confidence_score"],
                    validation_method=assoc["validation_method"],
                    validated_by=assoc.get("validated_by"),
                    validated_at=assoc.get("validated_at", datetime.now(UTC)),
                )
                association_models.append(confirmation)

            # Create the event
            event = StudentAssociationsConfirmedV1(
                batch_id=batch_id,
                class_id=class_id,
                associations=association_models,
                timeout_triggered=timeout_triggered,
                validation_summary=validation_summary,
            )

            # Create event envelope
            envelope: EventEnvelope = EventEnvelope(
                event_id=UUID("00000000-0000-0000-0000-000000000000"),  # Will be generated by outbox
                event_type=topic_name(ProcessingEvent.STUDENT_ASSOCIATIONS_CONFIRMED),
                event_timestamp=datetime.now(UTC),
                source_service="class_management_service",
                correlation_id=correlation_id,
                data=event,
                metadata={
                    "batch_id": batch_id,
                    "class_id": class_id,
                    "partition_key": batch_id,  # Partition by batch for ordering
                },
            )

            # Use outbox pattern for reliable delivery
            await self.outbox_manager.publish_to_outbox(
                aggregate_id=batch_id,
                aggregate_type="batch",
                event_type=envelope.event_type,
                event_data=envelope,
                topic=topic_name(ProcessingEvent.STUDENT_ASSOCIATIONS_CONFIRMED),
            )

            logger.info(
                "StudentAssociationsConfirmedV1 published via outbox",
                extra={
                    "batch_id": batch_id,
                    "class_id": class_id,
                    "correlation_id": str(correlation_id),
                    "association_count": len(associations),
                    "timeout_triggered": timeout_triggered,
                },
            )

        except Exception as e:
            logger.error(
                f"Failed to publish student associations confirmed: {e}",
                extra={
                    "batch_id": batch_id,
                    "class_id": class_id,
                    "correlation_id": str(correlation_id),
                },
                exc_info=True,
            )
            raise_external_service_error(
                service="class_management_service",
                operation="publish_student_associations_confirmed",
                external_service="outbox",
                message=f"Failed to publish student associations confirmed: {str(e)}",
                correlation_id=correlation_id,
                batch_id=batch_id,
                class_id=class_id,
            )