"""
E2E Pipeline Test - Step 3: Complete Workflow Test

Simple, clean test demonstrating the complete workflow:
1. Register batch via BOS
2. Upload files via File Service
3. Monitor Kafka events
4. Validate ELS integration

No mocking - tests real services only.
"""

import asyncio
import json
import uuid
from pathlib import Path

import httpx
import pytest
from aiokafka import AIOKafkaConsumer


@pytest.mark.e2e
@pytest.mark.docker
@pytest.mark.asyncio
async def test_complete_workflow_file_to_els():
    """
    Test the complete workflow from batch registration through ELS integration.

    This demonstrates the proper sequence:
    1. BOS batch registration
    2. File Service upload
    3. Kafka event flow
    4. ELS essay entity creation
    """
    test_file = Path("test_uploads/essay1.txt")
    assert test_file.exists(), f"Test file {test_file} not found"

    batch_id = f"e2e-complete-{uuid.uuid4().hex[:8]}"

    print(f"üéØ Testing complete workflow for batch: {batch_id}")

    # Step 1: Register batch via BOS
    print("üìã Step 1: Registering batch via BOS...")
    async with httpx.AsyncClient() as client:
        registration_data = {
            "expected_essay_count": 1,
            "course_code": "E2E_TEST",
            "class_designation": "Test Class Phase3",
            "teacher_name": "Test Teacher",
            "essay_instructions": "Write a test essay for E2E validation",
            "enable_cj_assessment": False
        }

        response = await client.post(
            "http://localhost:5001/v1/batches/register",
            json=registration_data,
            timeout=10.0
        )

        assert response.status_code == 202, (
            f"BOS registration failed: {response.status_code}: {response.text}"
        )

        registration_response = response.json()
        actual_batch_id = registration_response["batch_id"]
        correlation_id = registration_response.get("correlation_id")

        print(f"‚úÖ BOS registered batch: {actual_batch_id} (correlation: {correlation_id})")

        # Update our batch_id to use the one generated by BOS
        batch_id = actual_batch_id

    # Step 2: Wait for ELS to process BatchEssaysRegistered event
    print("‚è≥ Step 2: Waiting for ELS to process batch registration...")
    await asyncio.sleep(3)

    # Step 3: Upload file via File Service
    print("üì§ Step 3: Uploading file via File Service...")
    async with httpx.AsyncClient() as client:
        with open(test_file, "rb") as f:
            files = {"files": (test_file.name, f, "text/plain")}
            data = {"batch_id": batch_id}

            response = await client.post(
                "http://localhost:7001/v1/files/batch",
                files=files,
                data=data,
                timeout=30.0
            )

            assert response.status_code == 202, (
                f"File upload failed: {response.status_code}: {response.text}"
            )

            upload_response = response.json()
            print(f"‚úÖ File uploaded: {upload_response}")

    # Step 4: Monitor Kafka for EssayContentProvisionedV1 event
    print("üì® Step 4: Monitoring Kafka events...")
    consumer = AIOKafkaConsumer(
        "huleedu.file.essay.content.provisioned.v1",
        bootstrap_servers="localhost:9093",
        auto_offset_reset="earliest",
        group_id=f"e2e-complete-test-{uuid.uuid4().hex[:8]}",
        value_deserializer=lambda m: json.loads(m.decode("utf-8")),
        client_id=f"e2e-complete-client-{uuid.uuid4().hex[:8]}",
        fetch_max_wait_ms=1000,
        max_poll_records=10
    )

    event_found = False
    try:
        await consumer.start()

        async with asyncio.timeout(30):
            async for message in consumer:
                event_data = message.value

                if ("data" in event_data and
                    event_data["data"].get("batch_id") == batch_id):

                    print(f"‚úÖ EssayContentProvisionedV1 event received: "
                          f"{event_data['data']['original_file_name']}")
                    event_found = True
                    break

    except asyncio.TimeoutError:
        pytest.fail("EssayContentProvisionedV1 event not received within 30 seconds")
    finally:
        await consumer.stop()

    assert event_found, "Expected Kafka event was not found"

    # Step 5: Wait for ELS to process the content event
    print("‚è≥ Step 5: Waiting for ELS to process content event...")
    await asyncio.sleep(5)

    # Step 6: Query ELS to validate essay entity creation
    print("üîç Step 6: Querying ELS for essay entities...")
    async with httpx.AsyncClient() as client:
        response = await client.get(
            f"http://localhost:6001/v1/batches/{batch_id}/status",
            timeout=10.0
        )

        if response.status_code == 404:
            # Check if ELS worker processed the event but had issues
            print("‚ùå ELS batch not found - checking ELS worker logs for processing status")
            pytest.fail(
                f"Batch {batch_id} not found in ELS despite proper registration and "
                "content events. This suggests ELS is not creating essay entities "
                "from the content."
            )

        assert response.status_code == 200, (
            f"ELS batch query failed: {response.status_code}: {response.text}"
        )

        batch_status = response.json()
        print(f"‚úÖ ELS batch status: {batch_status}")

        # Validate the workflow succeeded
        assert batch_status["total_essays"] == 1, (
            f"Expected 1 essay in batch, got {batch_status['total_essays']}"
        )
        assert batch_status["batch_id"] == batch_id

        print("üéâ Phase 3 SUCCESS: Complete workflow validated!")
        print("   - Batch registered via BOS ‚úÖ")
        print("   - File uploaded via File Service ‚úÖ")
        print("   - Kafka events published and consumed ‚úÖ")
        print("   - ELS essay entity created ‚úÖ")
        print("   - End-to-end integration working! ‚úÖ")


@pytest.mark.e2e
@pytest.mark.docker
@pytest.mark.asyncio
async def test_bos_connectivity_prerequisite():
    """Verify BOS service is accessible for batch registration."""
    async with httpx.AsyncClient() as client:
        try:
            # Test BOS health/connectivity (all services use consistent /healthz pattern)
            response = await client.get("http://localhost:5001/healthz", timeout=5.0)
            assert response.status_code == 200, f"BOS health check failed: {response.status_code}"
            print("‚úÖ BOS service connectivity confirmed")
        except httpx.ConnectError:
            pytest.skip("BOS service not accessible - ensure docker compose up -d is running")
        except httpx.TimeoutException:
            pytest.fail("BOS service response timeout")
